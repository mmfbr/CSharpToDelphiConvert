// Marcelo Melo
// 10/11/2020 - Criação inicial
// 22-03-2024 - Suporte a SwitchExpressionSyntax
// 22/03/2024 - Suporte a ImplicitObjectCreationExpressionSyntax
// 22/03/2024 - Suporte a ImplicitObjectCreationExpressionSyntax -EqualsValueClauseSyntax
// 22/03/2024 - Suporte a destroy estatico de classes (class destructor Destroy)
// 22/03/2024 - Suporte a prefixo de acesso ao ponteiro (@pointer) PrefixUnaryExpressionSyntax para SyntaxKind.AddressOfExpression (na pratica troca o & por @ para acesso ao ponteiro)
// 22/03/2024 - Suporte a expressões para valores de array (CollectionExpressionSyntax)
// 22/03/2024 - Suporte a FixedStatementSyntax para declaração de variavel de ponteiro exemplo: fixed (int* variavelPointer = variavel) { }
// 22/03/2024 - Adicionado suporte a stackalloc  (alocação na pilha) para StackAllocArrayCreationExpressionSyntax
// 23/03/2024 - Adicionado geração da saida {$REGION 'TTypeName'} e {$ENDREGION 'TTypeName'} para os tipos.
// 25/03/2024 - Refeito a maneira de gerar os comentarios, a documentação e as diretivas de compilação,
//				separando a geração para LeadingTrivia e TrailingTrivia em 2 metodos separados.
//				Criados os 2 novos metodos GenerateLeadingTriviaSyntax() e GenerateTrailingTriviaSyntax().
// 25/03/2024 - Suporte de SyntaxTrivia para directivas do compilador:
//				$REGION, $ENDREGION, {$IFDEF}, {$ELSE}, {$ELSEIF}, {$ENDIF}, {$DEFINE} e {$UNDEF}
// 25/03/2024 - Suporte para avaliação de expressões para valores de tipos enumerados
// 27/03/2024 - Suporte a sobrecarga do operador, (class operator) para conversão de tipo. (ConversionOperatorDeclarationSyntax)
// 02/04/2024 - Serviço de tradução de comentarios e documentação (TranslatorService)

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.CodeDom.Compiler;
using static System.Net.Mime.MediaTypeNames;


namespace CSharpToObjectPascal
{
    public class ObjectPascalCodeGenerator
    {
		private static CodeGeneratorOptions defaultOptions;
		protected CodeGeneratorOptions options;
		internal IndentedTextWriter output;
		public ObjectPascalCodeGenerator()
        {
        }

		public int Indent
		{
			get
			{
				return output.Indent;
			}
			set
			{
				output.Indent = value;
			}
		}

		private int MaxLineLength
		{
			get
			{
				CodeGeneratorOptions codeGeneratorOptions = options;
				if (codeGeneratorOptions == null)
				{
					codeGeneratorOptions = DefaultOptions;
				}
				object obj = codeGeneratorOptions["WrapLocation"];
				if (obj != null)
				{
					return (int)obj;
				}
				return 78;
			}
		}

		protected CodeGeneratorOptions DefaultOptions
		{
			get
			{
				if (defaultOptions == null)
				{
					defaultOptions = new ObjectPascalCodeGeneratorOptions();
				}
				return defaultOptions;
			}
		}



		protected IndentedTextWriter GetWrapTextWriter(TextWriter w, bool indentNextLines)
		{
			WrappedTextWriter wrappedTextWriter = new WrappedTextWriter(w, '|', MaxLineLength, indentNextLines);
            return wrappedTextWriter.IndentedWriter = new IndentedTextWriter(wrappedTextWriter, options.IndentString);
		}

		public bool InitOutput(TextWriter w, ObjectPascalCodeGeneratorOptions o)
		{
			bool result = false;
			if (output != null && w != output.InnerWriter)
			{
				throw new InvalidOperationException("strCodeGenOutputWriter");
			}

			if (output == null)
			{
				result = true;
				options = ((o == null) ? DefaultOptions : o);
				output = GetWrapTextWriter(w, indentNextLines: true);
			}
			return result;
		}

		public void ResetOutput(bool reset)
		{
			if (reset)
			{
				output = null;
			}
		}


		public void GenerateCodeFromCompilationUnit(CompilationUnitSyntax e, TextWriter w, ObjectPascalCodeGeneratorOptions o)
		{
			bool reset = InitOutput(w, o);
			try
			{
				GenerateCodeLetsGo(e, o);
			}
			finally
			{
				ResetOutput(reset);
			}
		}

		public void GenerateCompilationUnitStart()
		{
			//output.WriteLine("//------------------------------------------------------------------------------");
			//output.WriteLine("// <autogenerated>");
			//output.WriteLine("//     Este código foi gerado pela ferramenta ObjectPascalCodeGenerator.");
			//output.WriteLine("//     Versão de tempo de execução: " + Environment.Version.ToString());
			//output.WriteLine("//");
			//output.WriteLine("//     Alterações neste arquivo podem causar comportamento incorreto e serão ");
			//output.WriteLine("//     perdidas se o código é regenerado.");
			//output.WriteLine("// </autogenerated>");
			//output.WriteLine("//------------------------------------------------------------------------------");
			//output.WriteLine("");
		}

		private void OutputIdentifier(NameSyntax ident)
		{
			output.Write(CodeGenUtils.CreateEscapedIdentifier(ident));
		}

		private void OutputIdentifier(string ident)
		{
			output.Write(CodeGenUtils.CreateEscapedIdentifier(ident));
		}

		private void GenerateNamespaceStart(BaseNamespaceDeclarationSyntax e, ObjectPascalCodeGeneratorOptions o)
		{
			string unitName = o.unitName ?? Path.GetFileNameWithoutExtension(e.SyntaxTree.FilePath);
            

            if (String.IsNullOrWhiteSpace(unitName))
				unitName = e.Name.ToString();

			if (o.UnitNameWithNamespaceName)
			{				
				unitName = e.Name.ToString() + "." + unitName;
			}

			GenerateCommentsTrivia(e);

			output.Write("unit ");
			OutputIdentifier(unitName);
			output.WriteLine(";");
			output.WriteLine("");
            output.WriteLine("{$INCLUDE Seven.inc}");           
            output.WriteLine("");
			output.WriteLine("interface");
		}


		private void GenerateNamespaceEnd(BaseNamespaceDeclarationSyntax e)
		{
			output.WriteLine();
			output.WriteLine("end.");
		}


		protected void GenerateClassDeclarationIdentifier(ClassDeclarationSyntax classDeclaration)
        {

			GenerateLeadingTriviaSyntax(classDeclaration);
            GenerateAttributes(classDeclaration.AttributeLists);
                      
            output.Write(CSharpToObjectPascalType(classDeclaration.Identifier.ValueText));


            if (classDeclaration.TypeParameterList != null)
				output.Write(classDeclaration.TypeParameterList.ToString());

			output.Write(" = class");

			if (classDeclaration.Modifiers.IndexOf(SyntaxKind.AbstractKeyword) > -1)
				output.Write(" abstract");
			else if (classDeclaration.Modifiers.IndexOf(SyntaxKind.SealedKeyword) > -1)
				output.Write(" sealed");
			else if (classDeclaration.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write(" sealed");


			if (classDeclaration.BaseList != null)
			{
				output.Write("(");

				foreach (BaseTypeSyntax baseTypeSyntax in classDeclaration.BaseList.Types)
				{
					if (baseTypeSyntax.Equals(classDeclaration.BaseList.Types.First()))
					{
						if (baseTypeSyntax.Type.ToString()[0].Equals('I') && Char.IsUpper(baseTypeSyntax.Type.ToString()[1]))
                        {
							output.Write("TInterfacedObject, ");

						}
					}

					output.Write(CSharpToObjectPascalType(baseTypeSyntax.Type));

					if (!baseTypeSyntax.Equals(classDeclaration.BaseList.Types.Last()))
					{
						output.Write(", ");
					}

				}

				output.Write(")");
			}


			if (classDeclaration.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write(" (* static *)");

			if (classDeclaration.Modifiers.IndexOf(SyntaxKind.PartialKeyword) > -1)
				output.Write(" (* partial *)");

        }

        protected void GenerateInterfaceDeclarationNameSyntax(InterfaceDeclarationSyntax e)
		{
			
			output.Write(e.Identifier.ValueText);

			if (e.TypeParameterList != null)
				output.Write(e.TypeParameterList.ToString());

			output.Write(" = ");
			output.Write("interface");

			if (e.BaseList != null)
			{
				output.Write("(");

				foreach (BaseTypeSyntax baseTypeSyntax in e.BaseList.Types)
				{

					output.Write(CSharpToObjectPascalType(baseTypeSyntax.Type));

					if (!baseTypeSyntax.Equals(e.BaseList.Types.Last()))
					{
						output.Write(", ");
					}

				}

				output.Write(")");
			}

			output.WriteLine();
			output.Indent++;

			string guid = Guid.NewGuid().ToString().ToUpper();

			foreach (var attributeListSyntax in e.AttributeLists)
            {
				foreach(var attribute in attributeListSyntax.Attributes)
                {
					if (attribute.Name.ToFullString().Equals("Guid"))
					{
						foreach(var arg in attribute.ArgumentList.Arguments)
                        {
							guid = arg.ToString();
							guid = guid.ToString().Substring(1, guid.Length - 2);
						}
					}
				}

			}
			

			output.Write(@"['{");
			output.Write(guid);
			output.WriteLine(@"}']");
			output.Indent--;
		}


		private void GenerateFieldDeclarationSyntax(FieldDeclarationSyntax fieldDeclarationSyntax)
		{


			GenerateCommentsTrivia(fieldDeclarationSyntax);
            GenerateAttributes(fieldDeclarationSyntax.AttributeLists);


            foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in fieldDeclarationSyntax.Declaration.Variables)
			{
				if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
					output.Write("public ");
				else if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.InternalKeyword) > -1)
				{
					if (fieldDeclarationSyntax.Parent is StructDeclarationSyntax)
						output.Write("public ");
					else
						output.Write("protected ");
				}
				else if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ProtectedKeyword) > -1)
				{
					if (fieldDeclarationSyntax.Parent is StructDeclarationSyntax)
						output.Write("private ");
					else
						output.Write("strict protected ");
				}
				else if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
					output.Write("strict private ");
				else
					output.Write("public ");

				if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
					output.Write("class var ");

				if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
					output.Write("const ");

				if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.UnsafeKeyword) > -1)
                    output.WriteLine("[Unsafe]");

                if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.UnsafeKeyword) > -1)
                    output.WriteLine("[Unsafe]");


                output.Write(CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText));

                output.Write(": ");

                //if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ReadOnlyKeyword) > -1)
                //    output.Write("ReadOnly<");

                output.Write(CSharpToObjectPascalType(fieldDeclarationSyntax.Declaration.Type));

                //if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ReadOnlyKeyword) > -1)
                //    output.Write(">");


                if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
				{
					if (variableDeclaratorSyntax.Initializer != null)
					{
						output.Write(" = ");

						switch (variableDeclaratorSyntax.Initializer.Value.Kind())
						{
							case SyntaxKind.StringLiteralExpression:
								output.Write("'");
								output.Write(((LiteralExpressionSyntax)variableDeclaratorSyntax.Initializer.Value).Token.ValueText);
								output.Write("'");
								break;

							case SyntaxKind.NumericLiteralExpression:
								GenerateNumericLiteralExpressionSyntax(variableDeclaratorSyntax.Initializer.Value);
								//output.Write(((LiteralExpressionSyntax)variableDeclaratorSyntax.Initializer.Value).Token.ValueText);
								break;

							default:
								output.Write(variableDeclaratorSyntax.Initializer.Value.ToFullString());
								break;

						}

					}
				}
                if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ConstKeyword) == -1 &&
                    fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) == -1 &&
                    !variableDeclaratorSyntax.Identifier.ValueText.StartsWith("_") && 
					!variableDeclaratorSyntax.Identifier.ValueText.StartsWith("m_") &&
                    !variableDeclaratorSyntax.Identifier.ValueText.StartsWith("s_") &&
                    !variableDeclaratorSyntax.Identifier.ValueText.StartsWith("t_") &&
					fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) == -1)
                    output.WriteLine("; // Nome do campo não foi iniciado com \"_\" ou \"m_\", verifique se não esta duplicado com nome de propriedade pelo motivo que pascal não diferencia maiúsculas e minúsculas!");
				else
					output.WriteLine(";");



			}

		}

        internal void GenerateAttributes(SyntaxList<AttributeListSyntax> attributeLists)
		{

			foreach (var attributeListSyntax in attributeLists)
            {
                foreach (AttributeSyntax attribute in attributeListSyntax.Attributes)
                {

					string attributeStr = attribute.ToFullString().Replace("$", "").Replace("\"", "'");

					if (attribute.Name.ToString().Equals("InlineData"))
					{
						attributeStr = attributeStr.Replace("(", "('");
						attributeStr = attributeStr.Replace(")", "')");
					}

					output.Write("[");
                    output.Write(attributeStr);
                    output.Write("]");
                }

                GenerateTrailingTriviaSyntax(attributeListSyntax);

                output.WriteLine();
            }


        }

        internal void GenerateForwardTypes(NamespaceDeclarationSyntax e)
        {

			foreach (var type in e.Members)
			{
				if (type is InterfaceDeclarationSyntax)
				{
					var interfaceType = type as InterfaceDeclarationSyntax;
					output.Write(interfaceType.Identifier.ValueText);
					if (interfaceType.TypeParameterList != null)
						output.Write(interfaceType.TypeParameterList.ToString());

					output.WriteLine(" = interface;");
				}
				else if (type is ClassDeclarationSyntax)
				{
					var classType =  type as  ClassDeclarationSyntax;

                    output.Write(classType.Identifier.ValueText);
					if (classType.TypeParameterList != null)
						output.Write(classType.TypeParameterList.ToString());

					output.WriteLine(" = class;");
				}
			}


		}

		internal void GenerateEnumType(EnumDeclarationSyntax e)
        {

			if (e.Parent is not ClassDeclarationSyntax)
			{
				output.Write("{ ");

                output.Write(CSharpToObjectPascalType(e.Identifier.ValueText));

				output.Write(" }");
                output.WriteLine();
            }

            GenerateLeadingTriviaSyntax(e);
            GenerateAttributes(e.AttributeLists);

            bool hasFlagsAttribute = false;

            foreach (AttributeListSyntax attributeListSyntax in e.AttributeLists)
            {
                foreach (AttributeSyntax attribute in attributeListSyntax.Attributes)
                {
                    if (attribute.Name.ToFullString().Equals("Flags"))
                    {
                        hasFlagsAttribute = true;
						break;
                    }
                }

            }


            output.Write(CSharpToObjectPascalType(e.Identifier.ValueText));
			output.Write(" = ");

            if (hasFlagsAttribute)
            {
                output.Write("type UInt32;");
				GenerateTriviaListSyntax(e.Identifier.TrailingTrivia, true);

                output.WriteLine();
                output.Write(CSharpToObjectPascalType(e.Identifier.ValueText));
                output.Write("Helper = record helper for ");
                output.Write(CSharpToObjectPascalType(e.Identifier.ValueText));
            }
            else
			{
                output.Write("(");
				GenerateTriviaListSyntax(e.Identifier.TrailingTrivia, true);
            }

            output.WriteLine();

            output.Indent++;
			output.Indent++;

			var enumMemberDeclarationSyntaxCollection = e.ChildNodes().OfType<EnumMemberDeclarationSyntax>();

            foreach (EnumMemberDeclarationSyntax enumMemberDeclarationSyntax in enumMemberDeclarationSyntaxCollection)
			{
                GenerateLeadingTriviaSyntax(enumMemberDeclarationSyntax);
                GenerateAttributes(enumMemberDeclarationSyntax.AttributeLists);


                if (hasFlagsAttribute)
                    output.Write("public const ");


                output.Write(CodeGenUtils.CreateEscapedIdentifier(enumMemberDeclarationSyntax.Identifier.ValueText));

				if (enumMemberDeclarationSyntax.EqualsValue != null)
				{
					output.Write(" = ");
					GenerateExpressionSyntax(enumMemberDeclarationSyntax.EqualsValue.Value);
                }

                if (hasFlagsAttribute)
				{
					output.Write(";");
				}
				else if (!enumMemberDeclarationSyntax.Equals(enumMemberDeclarationSyntaxCollection.Last()))
                {
					output.Write(",");
				}

                GenerateTrailingTriviaSyntax(enumMemberDeclarationSyntax);

                output.WriteLine();
            }

            output.WriteLine();


            output.Indent--;
			output.Indent--;
			if (hasFlagsAttribute)
				output.Write("end;");
            else
                output.Write(");");



            GenerateTrailingTriviaSyntax(e);
            output.WriteLine();

        }
        internal void GenerateClassType(ClassDeclarationSyntax e, bool declaration)
        {
			if (declaration)
			{
				GenerateTypeDeclarations(e);
            }
            else
			{
				GenerateTypeImplementations(e);
			}
		}

        //private void GenerateConstructorBobySyntax(ConstructorDeclarationSyntax e)
        //      {
        //	output.WriteLine("begin");

        //	if (e.Initializer != null)
        //          {
        //		GenerateConstructorInitializerSyntax(e.Initializer);
        //		output.WriteLine();
        //	} 


        //	GenerateMethodBodySyntax(e.Body);

        //	output.WriteLine("end;");
        //}

        private void GenerateConstructorInitializerSyntax(ConstructorInitializerSyntax initializer)
        {
            output.Indent++;

            if (initializer.ThisOrBaseKeyword.IsKind(SyntaxKind.BaseKeyword))
                output.Write("inherited ");

            output.Write("Create(");
            GenerateArgumentListSyntax(initializer.ArgumentList);
            output.WriteLine(");");

            output.Indent--;
        }

        private void GenerateBeforeDestruction(ClassDeclarationSyntax e, bool declaration)
        {
			if (declaration)
			{
				output.WriteLine("public procedure BeforeDestruction; override;");
			}
			else
			{
				output.WriteLine();
				output.Write("procedure ");

				var qualifiedNames = new List<string>();

				qualifiedNames.Add(CSharpToObjectPascalType(e.Identifier.ValueText));
                if (e.TypeParameterList != null)
                    qualifiedNames[0] += e.TypeParameterList.ToString();

                var parentClass = e.Parent as ClassDeclarationSyntax;

				while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
				{
					qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
					parentClass = parentClass.Parent as ClassDeclarationSyntax;
				}

				foreach (var item in qualifiedNames)
				{
					output.Write(item);

					if (!item.Equals(qualifiedNames.Last()))
					{
						output.Write(".");
					}
				}


				output.Write(".");
				output.WriteLine("BeforeDestruction;");
				output.WriteLine("begin");
				output.Indent++;
				output.WriteLine("inherited;");

				var fieldDeclarationSyntaxCollection = e.ChildNodes().OfType<FieldDeclarationSyntax>();
				foreach (FieldDeclarationSyntax fieldDeclarationSyntax in fieldDeclarationSyntaxCollection)
				{

					if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
						continue;

					if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
						continue;

					foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in fieldDeclarationSyntax.Declaration.Variables)
					{

						if (variableDeclaratorSyntax.Initializer != null)
						{
							switch (variableDeclaratorSyntax.Initializer.Value.Kind())
							{
								case SyntaxKind.StringLiteralExpression:
								case SyntaxKind.NumericLiteralExpression:
								case SyntaxKind.CharacterLiteralExpression:
								case SyntaxKind.FalseLiteralExpression:
								case SyntaxKind.TrueLiteralExpression:
									continue;
							}

							var fieldName = CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText);

							output.Write("if not IsManagedType(");
							output.Write(fieldName);
							output.Write(") and Assigned(");
							output.Write(fieldName);
							output.Write(") then FreeAndNil(");
							output.Write(fieldName);
							output.WriteLine(");");
						}
					}



				}


				output.Indent--;
				output.WriteLine("end;");
			}
		}


        private void GenerateStaticClassConstruction(ClassDeclarationSyntax e, bool declaration)
        {
            if (declaration)
            {
                output.WriteLine("strict private class constructor CreateClass();");
            }
            else
            {
                output.WriteLine();
                output.Write("class constructor ");

                var qualifiedNames = new List<string>();

                qualifiedNames.Add(CSharpToObjectPascalType(e.Identifier.ValueText));
                if (e.TypeParameterList != null)
                    qualifiedNames[0] += e.TypeParameterList.ToString();

                var parentClass = e.Parent as ClassDeclarationSyntax;

                while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
                {
                    qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
                    parentClass = parentClass.Parent as ClassDeclarationSyntax;
                }

                foreach (var item in qualifiedNames)
                {
                    output.Write(item);

                    if (!item.Equals(qualifiedNames.Last()))
                    {
                        output.Write(".");
                    }
                }


                output.Write(".");
                output.WriteLine("CreateClass();");
                output.WriteLine("begin");
                output.Indent++;

                var fieldDeclarationSyntaxCollection = e.ChildNodes().OfType<FieldDeclarationSyntax>();
                foreach (FieldDeclarationSyntax fieldDeclarationSyntax in fieldDeclarationSyntaxCollection)
                {

                    foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in fieldDeclarationSyntax.Declaration.Variables)
                    {
                        if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) == -1)
                            break;

                        if (variableDeclaratorSyntax.Initializer != null)
                        {
                            if (variableDeclaratorSyntax.Initializer.Value is ArrayCreationExpressionSyntax)
                            {
                                output.Write(CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText));
                                output.Write(" := ");
                                GenerateArrayCreationExpressionSyntax((ArrayCreationExpressionSyntax)variableDeclaratorSyntax.Initializer.Value);
                            }
                            else
                            {
                                output.Write(CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText));
                                GenerateEqualsValueClause(variableDeclaratorSyntax.Initializer);
                            }

                            output.WriteLine(";");

                        }

                    }

                }


                output.Indent--;
                output.WriteLine("end;");
            }
        }

        private void GenerateStaticClassDestruction(ClassDeclarationSyntax e, bool declaration)
        {
            if (declaration)
            {
                output.WriteLine("strict private class destructor DestroyClass();");
            }
            else
            {
                output.WriteLine();
                output.Write("class destructor ");

                var qualifiedNames = new List<string>();

                qualifiedNames.Add(CSharpToObjectPascalType(e.Identifier.ValueText));
                if (e.TypeParameterList != null)
                    qualifiedNames[0] += e.TypeParameterList.ToString();

                var parentClass = e.Parent as ClassDeclarationSyntax;

                while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
                {
                    qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
                    parentClass = parentClass.Parent as ClassDeclarationSyntax;
                }

                foreach (var item in qualifiedNames)
                {
                    output.Write(item);

                    if (!item.Equals(qualifiedNames.Last()))
                    {
                        output.Write(".");
                    }
                }


                output.Write(".");
                output.WriteLine("DestroyClass();");
                output.WriteLine("begin");
                output.Indent++;

                var fieldDeclarationSyntaxCollection = e.ChildNodes().OfType<FieldDeclarationSyntax>();
                foreach (FieldDeclarationSyntax fieldDeclarationSyntax in fieldDeclarationSyntaxCollection)
                {

                    foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in fieldDeclarationSyntax.Declaration.Variables)
                    {
                        if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) == -1)
                            break;

                        if (variableDeclaratorSyntax.Initializer != null)
                        {
                            output.Write("FreeAndNil(");
                            output.Write(CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText));
                            output.Write(")");
                            output.WriteLine(";");

                        }

                    }

                }


                output.Indent--;
                output.WriteLine("end;");
            }
        }


        private void GenerateAfterConstruction(ClassDeclarationSyntax e, bool declaration)
        {
            if (declaration)
            {
				output.WriteLine("public procedure AfterConstruction; override;");
            }
			else
            {
				output.WriteLine();
				output.Write("procedure ");

				var qualifiedNames = new List<string>();

				qualifiedNames.Add(CSharpToObjectPascalType(e.Identifier.ValueText));
                if (e.TypeParameterList != null)
                    qualifiedNames[0] += e.TypeParameterList.ToString();

                var parentClass = e.Parent as ClassDeclarationSyntax;

				while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
				{
					qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
					parentClass = parentClass.Parent as ClassDeclarationSyntax;
				}

				foreach (var item in qualifiedNames)
				{
					output.Write(item);

					if (!item.Equals(qualifiedNames.Last()))
					{
						output.Write(".");
					}
				}


				output.Write(".");
				output.WriteLine("AfterConstruction;");
				output.WriteLine("begin");
				output.Indent++;
				output.WriteLine("inherited;");

                var propertyDeclarationSyntaxCollection = e.ChildNodes().OfType<PropertyDeclarationSyntax>();

                foreach (PropertyDeclarationSyntax propertyDeclarationSyntax in propertyDeclarationSyntaxCollection)
				{

                    if (propertyDeclarationSyntax.Initializer != null)
                    {
                        if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
                            break;

                        if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
                            break;

                        if (propertyDeclarationSyntax.Initializer != null)
                        {

                            if (propertyDeclarationSyntax.Initializer.Value is ArrayCreationExpressionSyntax)
                            {
                                output.Write("SetLength(");
                                output.Write("m_");
                                output.Write(CodeGenUtils.CreateEscapedIdentifier(propertyDeclarationSyntax.Identifier.ValueText));
                                output.Write(", ");

                                ArrayCreationExpressionSyntax arrayCreationExpressionSyntax = (ArrayCreationExpressionSyntax)propertyDeclarationSyntax.Initializer.Value;

                                ArrayTypeSyntax arrayTypeSyntax = arrayCreationExpressionSyntax.Type;

                                foreach (ArrayRankSpecifierSyntax arrayRankSpecifier in arrayTypeSyntax.RankSpecifiers)
                                {

                                    output.Write(arrayRankSpecifier.Sizes.ToString());

                                    if (!arrayRankSpecifier.Equals(arrayTypeSyntax.RankSpecifiers.Last()))
                                    {
                                        output.Write(", ");
                                    }
                                }


                                output.Write(")");

                            }
                            else
                            {
								output.Write("m_");
                                output.Write(CodeGenUtils.CreateEscapedIdentifier(propertyDeclarationSyntax.Identifier.ValueText));
                                GenerateEqualsValueClause(propertyDeclarationSyntax.Initializer);
                            }

                            output.WriteLine(";");

                        }

                    }


                }

                var fieldDeclarationSyntaxCollection = e.ChildNodes().OfType<FieldDeclarationSyntax>();
				foreach (FieldDeclarationSyntax fieldDeclarationSyntax in fieldDeclarationSyntaxCollection)
				{

					foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in fieldDeclarationSyntax.Declaration.Variables)
					{
						if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							break;

						if (fieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
							break;

						if (variableDeclaratorSyntax.Initializer != null)
						{

							if (variableDeclaratorSyntax.Initializer.Value is ArrayCreationExpressionSyntax)
							{
                                output.Write(CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText));
                                output.Write(" := ");
                                GenerateArrayCreationExpressionSyntax((ArrayCreationExpressionSyntax)variableDeclaratorSyntax.Initializer.Value);

        //                        output.Write("SetLength(");
								//output.Write(CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText));
								//output.Write(", ");

								//ArrayCreationExpressionSyntax arrayCreationExpressionSyntax = (ArrayCreationExpressionSyntax)variableDeclaratorSyntax.Initializer.Value;

								//ArrayTypeSyntax arrayTypeSyntax = arrayCreationExpressionSyntax.Type;

								//foreach (ArrayRankSpecifierSyntax arrayRankSpecifier in arrayTypeSyntax.RankSpecifiers)
								//{

								//	output.Write(arrayRankSpecifier.Sizes.ToString());

								//	if (!arrayRankSpecifier.Equals(arrayTypeSyntax.RankSpecifiers.Last()))
								//	{
								//		output.Write(", ");
								//	}
								//}


								//output.Write(")");

							} 
							else
                            {
								output.Write(CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText));
								GenerateEqualsValueClause(variableDeclaratorSyntax.Initializer);
							}

							output.WriteLine(";");

						}

					}

				}


				output.Indent--;
				output.WriteLine("end;");
			}
		}

		private void GenerateIndexerDeclarationSyntax(IndexerDeclarationSyntax indexerDeclarationSyntax)
        {


			if (indexerDeclarationSyntax.HasLeadingTrivia)
			{
				SyntaxTriviaList syntaxTriviaList = indexerDeclarationSyntax.GetLeadingTrivia();
				foreach (SyntaxTrivia syntaxTrivia in syntaxTriviaList)
				{
					if (syntaxTrivia.IsKind(SyntaxKind.SingleLineCommentTrivia))
						output.WriteLine(syntaxTrivia.ToFullString());
				}

			}

			SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = indexerDeclarationSyntax.ParameterList.Parameters;

			foreach (AccessorDeclarationSyntax accessorDeclarationSyntax in indexerDeclarationSyntax.AccessorList.Accessors)
			{
				if (accessorDeclarationSyntax.IsKind(SyntaxKind.GetAccessorDeclaration))
				{

					output.Write("strict private ");

					if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
						output.Write("class ");

                    // Retirado o final do nome GetIndexerItemValue para GetItem em 10/11/2023 para analise se melhorou
                    //output.Write(@"function GetIndexerItemValue(");
                    output.Write(@"function GetItem(");

                    foreach (ParameterSyntax param in parameterSyntaxCollection)
					{
						GenerateParameterSyntax(param);
						if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
							output.Write("const ");
						else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
							output.Write("var ");
						else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
							output.Write("out ");
						else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
							output.Write("const ");
						else 
							output.Write("const ");

						//output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.Text));
						//output.Write(": " + CSharpToObjectPascalType(param.Type));

						if (!param.Equals(parameterSyntaxCollection.Last()))
							output.Write("; ");
					}


					output.Write("): " + CSharpToObjectPascalType(indexerDeclarationSyntax.Type));

					if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
						output.Write("; static");

                    if (ContainsAggressiveInliningMethodImpl(accessorDeclarationSyntax.AttributeLists))
                        output.Write("; inline");

                    output.WriteLine(";");
				}
				else if (accessorDeclarationSyntax.IsKind(SyntaxKind.SetAccessorDeclaration))
				{
//					if (accessorDeclarationSyntax.Body != null) // auto property
					{

						output.Write("strict private ");

						if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("class ");


                        // Retirado o final do nome SetIndexerItemValue para SetItem em 10/11/2023 para analise se melhorou
                        // output.Write(@"procedure SetIndexerItemValue(");
                        output.Write(@"procedure SetItem(");

                        foreach (ParameterSyntax param in parameterSyntaxCollection)
						{
							if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
								output.Write("const ");
							else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
								output.Write("var ");
							else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
								output.Write("out ");
							else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
								output.Write("const ");
							else
								output.Write("const ");

							output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.Text));
							output.Write(": " + CSharpToObjectPascalType(param.Type));

 							output.Write("; ");
						}


						output.Write("const Value: " + CSharpToObjectPascalType(indexerDeclarationSyntax.Type) + ")");

						if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("; static");

                        if (ContainsAggressiveInliningMethodImpl(accessorDeclarationSyntax.AttributeLists))
                            output.Write("; inline");

                        output.WriteLine(";");
					}
				}
				else
				{
					var node = accessorDeclarationSyntax;
                    var kind = node.Kind();
					FileLinePositionSpan span = node.SyntaxTree.GetLineSpan(node.Span);
					int lineNumber = span.StartLinePosition.Line + 1;

					output.WriteLine();
                    output.WriteLine("  //");
                    output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                    output.WriteLine("  // Kind: " + node.Kind().ToString());
                    output.WriteLine("  // Type: " + node.GetType().Name);
                    output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                    output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                    output.WriteLine("  // Linha: " + lineNumber.ToString());
                    output.WriteLine("  //");
                    output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                    output.WriteLine(node.ToFullString());
                    output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 04/03/2024-3 ------------");
                    output.WriteLine("  //");


                    //throw new NotImplementedException();
                }
            }

            GenerateCommentsTrivia(indexerDeclarationSyntax);
            GenerateAttributes(indexerDeclarationSyntax.AttributeLists);

            if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
				output.Write("public ");
            else if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.InternalKeyword) > -1)
			{
				if (indexerDeclarationSyntax.Parent is StructDeclarationSyntax)
					output.Write("public ");
				else
					output.Write("protected ");
			}
			else if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ProtectedKeyword) > -1)
			{
				if (indexerDeclarationSyntax.Parent is StructDeclarationSyntax)
					output.Write("private ");
				else
					output.Write("strict protected ");
			}
			else if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
				output.Write("strict private ");
			else
				output.Write("public ");

			if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write("class ");

			output.Write("property Items[");

			foreach (ParameterSyntax param in parameterSyntaxCollection)
			{
				if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
					output.Write("const ");
				else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
					output.Write("var ");
				else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
					output.Write("out ");
				else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
					output.Write("const ");
				else
					output.Write("const ");

				output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.Text));
				output.Write(": " + CSharpToObjectPascalType(param.Type));

				if (!param.Equals(parameterSyntaxCollection.Last()))
					output.Write("; ");
			}


			output.Write("]: " + CSharpToObjectPascalType(indexerDeclarationSyntax.Type));

			foreach (AccessorDeclarationSyntax accessorDeclarationSyntax in indexerDeclarationSyntax.AccessorList.Accessors)
			{
				if (accessorDeclarationSyntax.IsKind(SyntaxKind.GetAccessorDeclaration))
				{
					output.Write(" read ");
                    // Retirado o final do nome GetIndexerItemValue para GetItem em 10/11/2023 para analise se melhorou
                    // output.Write("GetIndexerItemValue");
                    output.Write("GetItem");
                }
                else if (accessorDeclarationSyntax.IsKind(SyntaxKind.SetAccessorDeclaration))
				{
					output.Write(" write ");
                    // Retirado o final do nome SetIndexerItemValue para SetItem em 10/11/2023 para analise se melhorou
                    // output.Write("SetIndexerItemValue");
                    output.Write("SetItem");
                }
            }

			output.WriteLine("; default;");


		}

		private void GenerateArrowExpressionClauseSyntaxForPropertyDeclarationSyntax(PropertyDeclarationSyntax propertyDeclarationSyntax)
        {

			output.Write("strict private ");

			if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write("class ");

			output.Write("function Get" + propertyDeclarationSyntax.Identifier.ValueText + "(): " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type));

			if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write("; static");

            if (ContainsAggressiveInliningMethodImpl(propertyDeclarationSyntax.AttributeLists))
                output.Write("; inline");

            output.WriteLine(";");

            GenerateCommentsTrivia(propertyDeclarationSyntax);
            GenerateAttributes(propertyDeclarationSyntax.AttributeLists);

            if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
				output.Write("public ");
            else if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.InternalKeyword) > -1)
            {
				if (propertyDeclarationSyntax.Parent is StructDeclarationSyntax)
					output.Write("public ");
				else
					output.Write("protected ");
			}
			else if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ProtectedKeyword) > -1)
			{
				if (propertyDeclarationSyntax.Parent is StructDeclarationSyntax)
					output.Write("private ");
				else
					output.Write("strict protected ");
			}
			else if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
				output.Write("strict private ");
			else
				output.Write("public ");

			if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write("class ");

			output.Write("property " + CodeGenUtils.CreateEscapedIdentifier(propertyDeclarationSyntax.Identifier.ValueText) + ": " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type));

			output.Write(" read ");
			output.Write("Get" + propertyDeclarationSyntax.Identifier.ValueText);

			output.WriteLine(";");
		}

        private void GenerateEventFieldDeclarationSyntax(EventFieldDeclarationSyntax eventFieldDeclarationSyntax)
		{


			if (eventFieldDeclarationSyntax.Parent is InterfaceDeclarationSyntax)
			{
				foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in eventFieldDeclarationSyntax.Declaration.Variables)
				{
					var eventName = CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText);

					output.Write("function Get");
					output.Write(eventName + "EventValue(): " + CSharpToObjectPascalType(eventFieldDeclarationSyntax.Declaration.Type));
					output.WriteLine(";");

					output.Write("procedure Set");
					output.Write(eventName + "EventValue(const Value: " + CSharpToObjectPascalType(eventFieldDeclarationSyntax.Declaration.Type) + ")");
					output.WriteLine(";");

                    GenerateCommentsTrivia(eventFieldDeclarationSyntax);
                    GenerateAttributes(eventFieldDeclarationSyntax.AttributeLists);

                    output.Write("property ");
					output.Write(eventName + ": " + CSharpToObjectPascalType(eventFieldDeclarationSyntax.Declaration.Type));
					output.Write(" read ");
					output.Write("Get" + eventName + "EventValue");
					output.Write(" write ");
					output.Write("Set" + eventName + "EventValue");
					output.WriteLine(";");

				}
			}
			else
			{
				foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in eventFieldDeclarationSyntax.Declaration.Variables)
				{
                    GenerateCommentsTrivia(eventFieldDeclarationSyntax);
                    GenerateAttributes(eventFieldDeclarationSyntax.AttributeLists);

                    if (eventFieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
						output.Write("public ");
                    else if (eventFieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.InternalKeyword) > -1)
					{
						if (eventFieldDeclarationSyntax.Parent is StructDeclarationSyntax)
							output.Write("public ");
						else
							output.Write("protected ");
					}
					else if (eventFieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ProtectedKeyword) > -1)
					{
						if (eventFieldDeclarationSyntax.Parent is StructDeclarationSyntax)
							output.Write("private ");
						else
							output.Write("strict protected ");
					}
					else if (eventFieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
						output.Write("strict private ");
					else
						output.Write("public ");

					if (eventFieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
						output.Write("class var ");

					if (eventFieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
						output.Write("const ");

					if (eventFieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
						output.Write("m_");

					output.Write(CodeGenUtils.CreateEscapedIdentifier(variableDeclaratorSyntax.Identifier.ValueText) + ": " + CSharpToObjectPascalType(eventFieldDeclarationSyntax.Declaration.Type));

					if (eventFieldDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
					{
						if (variableDeclaratorSyntax.Initializer != null)
						{
							output.Write(" = ");

							switch (variableDeclaratorSyntax.Initializer.Value.Kind())
							{
								case SyntaxKind.StringLiteralExpression:
									output.Write("'");
									output.Write(((LiteralExpressionSyntax)variableDeclaratorSyntax.Initializer.Value).Token.ValueText);
									output.Write("'");
									break;

								case SyntaxKind.NumericLiteralExpression:
									GenerateNumericLiteralExpressionSyntax(variableDeclaratorSyntax.Initializer.Value);
									//output.Write(((LiteralExpressionSyntax)variableDeclaratorSyntax.Initializer.Value).Token.ValueText);
									break;

								default:
									output.Write(variableDeclaratorSyntax.Initializer.Value.ToFullString());
									break;

							}

						}
					}

					output.WriteLine(";");
				}

			}
		}
		internal void GenerateDelegateDeclarationSyntax(DelegateDeclarationSyntax e)
        {
            GenerateCommentsTrivia(e);
            GenerateAttributes(e.AttributeLists);
            
			output.Write(CSharpToObjectPascalType(e.Identifier.ValueText));

            if (e.TypeParameterList != null)
                output.Write(e.TypeParameterList.ToString());

            output.Write(" = reference to ");

			if (e.ReturnType.ToString().Equals("void"))
				output.Write("procedure(");
		    else
				output.Write("function(");

			if (e.ParameterList != null)
			{
				SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = e.ParameterList.Parameters;
				foreach (ParameterSyntax param in parameterSyntaxCollection)
				{
					if (e.Identifier.ValueText.Equals("TErrorCallback") && param.Identifier.ValueText.Equals("length"))
                    {
						//Console.WriteLine();
                    }

					if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
						output.Write("const ");
					else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
						output.Write("var ");
					else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
						output.Write("out ");
					else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
						output.Write("const ");
					else
						output.Write("const ");

					output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.ValueText));
					output.Write(": " + CSharpToObjectPascalType(param.Type));

					if (!param.Equals(parameterSyntaxCollection.Last()))
						output.Write("; ");
				}

			}


			output.Write(")");

			if (!e.ReturnType.ToString().Equals("void"))
				output.Write(": " + CSharpToObjectPascalType(e.ReturnType));


			// output.WriteLine(" of object;");
            output.WriteLine(";");
        }

        private void GenerateEventDeclarationSyntax(EventDeclarationSyntax eventDeclarationSyntax)
        {

			if (eventDeclarationSyntax.HasLeadingTrivia)
			{
				SyntaxTriviaList syntaxTriviaList = eventDeclarationSyntax.GetLeadingTrivia();
					foreach (SyntaxTrivia syntaxTrivia in syntaxTriviaList)
					{
						if (syntaxTrivia.IsKind(SyntaxKind.SingleLineCommentTrivia))
							output.WriteLine(syntaxTrivia.ToFullString());
					}
			}


			foreach (AccessorDeclarationSyntax accessorDeclarationSyntax in eventDeclarationSyntax.AccessorList.Accessors)
			{
				if (accessorDeclarationSyntax.IsKind(SyntaxKind.GetAccessorDeclaration))
				{

					output.Write("strict private ");

					if (eventDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
						output.Write("class ");

					if ((accessorDeclarationSyntax.Body == null) && (accessorDeclarationSyntax.ExpressionBody == null)) // auto event
					{
						output.Write("m_" + eventDeclarationSyntax.Identifier.ValueText + ": " + CSharpToObjectPascalType(eventDeclarationSyntax.Type));
					}
					else
					{
						output.Write("function Get" + eventDeclarationSyntax.Identifier.ValueText + "EventValue(): " + CSharpToObjectPascalType(eventDeclarationSyntax.Type));

						if (eventDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("; static");

                        if (ContainsAggressiveInliningMethodImpl(accessorDeclarationSyntax.AttributeLists))
                            output.Write("; inline");
                    }


                    output.WriteLine(";");
				}
				else if (accessorDeclarationSyntax.IsKind(SyntaxKind.SetAccessorDeclaration))
				{
					if (accessorDeclarationSyntax.Body != null || accessorDeclarationSyntax.ExpressionBody != null) // auto event
					{

						output.Write("strict private ");

						if (eventDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("class ");

						output.Write("procedure Set" + eventDeclarationSyntax.Identifier.ValueText + "EventValue(const Value: " + CSharpToObjectPascalType(eventDeclarationSyntax.Type) + ")");

						if (eventDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("; static");

                        if (ContainsAggressiveInliningMethodImpl(accessorDeclarationSyntax.AttributeLists))
                            output.Write("; inline");

                        output.WriteLine(";");
					}
				}

			}

		}

		private void GenerateImplementationPropertyDeclarationSyntax(PropertyDeclarationSyntax propertyDeclarationSyntax)
		{
			var qualifiedNames = new List<string>();

			if (propertyDeclarationSyntax.Parent is ClassDeclarationSyntax)
			{
				ClassDeclarationSyntax classDeclarationSyntax = propertyDeclarationSyntax.Parent as ClassDeclarationSyntax;

				qualifiedNames.Add(CSharpToObjectPascalType(classDeclarationSyntax.Identifier.ValueText));
                if (classDeclarationSyntax.TypeParameterList != null)
                    qualifiedNames[0] += classDeclarationSyntax.TypeParameterList.ToString();

                var parentClass = classDeclarationSyntax.Parent as ClassDeclarationSyntax;

				while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
				{
					qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
					parentClass = parentClass.Parent as ClassDeclarationSyntax;
				}
			}
			else if (propertyDeclarationSyntax.Parent is StructDeclarationSyntax)
			{
				StructDeclarationSyntax structDeclarationSyntax = propertyDeclarationSyntax.Parent as StructDeclarationSyntax;

				qualifiedNames.Add(CSharpToObjectPascalType(structDeclarationSyntax.Identifier.ValueText));
                if (structDeclarationSyntax.TypeParameterList != null)
                    qualifiedNames[0] += structDeclarationSyntax.TypeParameterList.ToString();

                var parentStruct = structDeclarationSyntax.Parent as StructDeclarationSyntax;

				while (parentStruct != null && parentStruct.Kind() == SyntaxKind.StructDeclaration)
				{
					qualifiedNames.Insert(0, CSharpToObjectPascalType(parentStruct.Identifier.ValueText));
					parentStruct = parentStruct.Parent as StructDeclarationSyntax;
				}
			}

			if (propertyDeclarationSyntax.AccessorList != null)
			{

				foreach (AccessorDeclarationSyntax accessorDeclarationSyntax in propertyDeclarationSyntax.AccessorList.Accessors)
				{

					if (accessorDeclarationSyntax.Body == null && (accessorDeclarationSyntax.ExpressionBody == null))
					{
						continue;
					}

					if (accessorDeclarationSyntax.IsKind(SyntaxKind.GetAccessorDeclaration))
					{

						output.WriteLine();

						if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("class ");

						output.Write("function ");

						foreach (var item in qualifiedNames)
						{
							output.Write(item);

							if (!item.Equals(qualifiedNames.Last()))
							{
								output.Write(".");
							}
						}


						output.Write(".");

                        output.Write("Get" + propertyDeclarationSyntax.Identifier.ValueText + "(): " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type));
                        output.WriteLine(";");
						output.WriteLine("begin");

						if (accessorDeclarationSyntax.Body != null)
							GenerateBlockSyntax(accessorDeclarationSyntax.Body);
						else if (accessorDeclarationSyntax.ExpressionBody != null)
						{
							output.Indent++;
                            output.Write("Result := ");
                            GenerateExpressionSyntax(accessorDeclarationSyntax.ExpressionBody.Expression);
                            output.WriteLine(";");
                            output.Indent--;
                        }

                        output.WriteLine("end;");
					}
					else if (accessorDeclarationSyntax.IsKind(SyntaxKind.SetAccessorDeclaration))
					{
						output.WriteLine();

						if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("class ");

						output.Write("procedure ");

						foreach (var item in qualifiedNames)
						{
							output.Write(item);

							if (!item.Equals(qualifiedNames.Last()))
							{
								output.Write(".");
							}
						}


						output.Write(".");
                        
						// Retirado o final do nome PropValue em 10/11/2023 para analise se melhorou
                        // output.Write("Set" + propertyDeclarationSyntax.Identifier.ValueText + "PropValue(const Value: " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type) + ")");
                        output.Write("Set" + propertyDeclarationSyntax.Identifier.ValueText + "(const Value: " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type) + ")");
						output.WriteLine(";");
						output.WriteLine("begin");

                        if (accessorDeclarationSyntax.Body != null)
                            GenerateBlockSyntax(accessorDeclarationSyntax.Body);
                        else if (accessorDeclarationSyntax.ExpressionBody != null)
                        {
                            output.Indent++;
                            GenerateExpressionSyntax(accessorDeclarationSyntax.ExpressionBody.Expression);
                            output.Indent--;
                        }

						output.WriteLine("end;");
					}
				} 
			}
			else if (propertyDeclarationSyntax.ExpressionBody != null)
			{
				output.WriteLine();

				if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
					output.Write("class ");

				output.Write("function ");

				foreach (var item in qualifiedNames)
				{
					output.Write(item);

					if (!item.Equals(qualifiedNames.Last()))
					{
						output.Write(".");
					}
				}


				output.Write(".");
                // Retirado o final do nome PropValue em 10/11/2023 para analise se melhorou
                //output.Write("Get" + propertyDeclarationSyntax.Identifier.ValueText + "PropValue(): " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type));
                output.Write("Get" + propertyDeclarationSyntax.Identifier.ValueText + "(): " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type));
                output.WriteLine(";");
				output.WriteLine("begin");
				output.Indent++;
				output.Write("Result := ");
				GenerateExpressionSyntax(propertyDeclarationSyntax.ExpressionBody.Expression);
				output.WriteLine(";");
				output.Indent--;
				output.WriteLine("end;");

			}

		}

		private void GenerateEqualsValueClause(EqualsValueClauseSyntax node)
		{

			output.Write(" := ");
			GenerateExpressionSyntax(node.Value);


		}


		private void GenerateVariableDeclaratorSyntax(VariableDeclaratorSyntax e)
		{

			if (e.Parent is VariableDeclarationSyntax)
			{
				VariableDeclarationSyntax variableDeclarationSyntax = e.Parent as VariableDeclarationSyntax;
				LocalDeclarationStatementSyntax localDeclaration = variableDeclarationSyntax.Parent as LocalDeclarationStatementSyntax;

                GenerateTriviaListSyntax(variableDeclarationSyntax.GetLeadingTrivia());

                if (localDeclaration != null && localDeclaration.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
                {
					output.Write("const ");
				}
				else
					output.Write("var ");

				var variableName = CodeGenUtils.CreateEscapedIdentifier(e.Identifier.ValueText);


                output.Write(variableName);

				if (!variableDeclarationSyntax.Type.IsVar)
					output.Write(": " + CSharpToObjectPascalType(variableDeclarationSyntax.Type));

				if (e.Initializer != null)
				{
					if (e.Initializer.IsKind(SyntaxKind.EqualsValueClause))
					{
						if (e.Initializer.Value is ImplicitObjectCreationExpressionSyntax implicitObjectCreation)
						{
							output.Write(" := ");
							output.Write(CSharpToObjectPascalType(variableDeclarationSyntax.Type));

							GenerateImplicitObjectCreationExpressionSyntax(implicitObjectCreation, variableDeclarationSyntax.Type);

							if (implicitObjectCreation.Initializer != null)
							{
								output.WriteLine(";");
								foreach (ExpressionSyntax expressionSyntax in implicitObjectCreation.Initializer.Expressions)
								{
									output.Write(variableName + ".");
									GenerateExpressionSyntax(expressionSyntax);
								}
							}
							else
							{
								output.Write(";");
							}
						}
						else if (e.Initializer.Value.IsKind(SyntaxKind.DefaultLiteralExpression))
						{
							output.Write(" := Default(");
							output.Write(CSharpToObjectPascalType(variableDeclarationSyntax.Type));
							output.Write(");");
						}
						else
						{
							GenerateEqualsValueClause(e.Initializer);

							if (e.Initializer.Value.IsKind(SyntaxKind.ObjectCreationExpression))
							{
								if (e.Initializer.Value is ObjectCreationExpressionSyntax objectCreationExpression)
								{

									if (objectCreationExpression.Initializer != null)
									{
										output.WriteLine(";");

										foreach (ExpressionSyntax expressionSyntax in objectCreationExpression.Initializer.Expressions)
										{
											output.Write(variableName + ".");

											GenerateExpressionSyntax(expressionSyntax);

											if (!expressionSyntax.Equals(objectCreationExpression.Initializer.Expressions.Last()))
											{
												//output.Write(", ");
											}
										}
									}
									else
									{
										output.Write(";");
									}
								}
								else
								{
									output.Write(";");
								}
							}
							else
							{
								output.Write(";");
							}
						}
					}
					else
					{
						output.WriteLine("Não implementado no conversor: " + e.Kind().ToString());
						output.WriteLine("nameof: " + nameof(e));
						output.WriteLine("GenerateVariableDeclaratorSyntax");
						output.WriteLine(e.ToFullString());
					}
				} 
				else
				{
                    output.Write(";");
                }

				if (localDeclaration != null)
					GenerateTriviaListSyntax(localDeclaration.SemicolonToken.TrailingTrivia);
            }

		}

        private void GenerateExpressionSyntax(ExpressionSyntax node)
        {
			if (node == null)
				return;

            var kind = node.Kind();
            FileLinePositionSpan span = node.SyntaxTree.GetLineSpan(node.Span);
            int lineNumber = span.StartLinePosition.Line + 1;

            switch (node.Kind())
			{
				case SyntaxKind.IdentifierName:
				case SyntaxKind.SimpleMemberAccessExpression:

					if (node is MemberAccessExpressionSyntax)
					{
						MemberAccessExpressionSyntax memberAccessExpressionSyntax = (MemberAccessExpressionSyntax)node;

						GenerateTriviaListSyntax(node.GetLeadingTrivia(), false);

						if (memberAccessExpressionSyntax.Expression is BaseExpressionSyntax)
                        {
							output.Write("inherited ");
                        } 
						else
                        {
							GenerateExpressionSyntax(memberAccessExpressionSyntax.Expression);
							output.Write(".");
						}

						output.Write(CodeGenUtils.CreateEscapedIdentifier(memberAccessExpressionSyntax.Name.Identifier.ValueText));

						if (memberAccessExpressionSyntax.Name is GenericNameSyntax genericName)
						{
							var nameParts = new StringBuilder();

							nameParts.Append("<");
							foreach (var argumentType in genericName.TypeArgumentList.Arguments)
							{
								nameParts.Append(CSharpToObjectPascalType(argumentType));

								if (!argumentType.Equals(genericName.TypeArgumentList.Arguments.Last()))
									nameParts.Append(", ");
							}
							nameParts.Append(">");


							output.Write(nameParts.ToString());

						}

					}
					else
					{

						if (node.ToString().Equals("this"))
							output.Write("Self");
						else
							output.Write(CodeGenUtils.CreateEscapedIdentifier(node.ToString()));
					}
					break;

				case SyntaxKind.TrueLiteralExpression:
				case SyntaxKind.FalseLiteralExpression:
					output.Write(node.ToString());
					break;

				case SyntaxKind.InvocationExpression:
					GenerateInvocationExpressionSyntax((InvocationExpressionSyntax)node);
					break;

				case SyntaxKind.StringLiteralExpression:
					output.Write("'");
					{
						LiteralExpressionSyntax literalExpression = node as LiteralExpressionSyntax;

						try
						{
							output.Write(literalExpression.Token.ValueText);
						}
						catch
						{
							output.WriteLine();
							output.WriteLine("  //");
							output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                            output.WriteLine("  // Kind: " + node.Kind().ToString());
                            output.WriteLine("  // Type: " + node.GetType().Name);
                            output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
							output.WriteLine("  // Posição: " + node.FullSpan.ToString());
							output.WriteLine("  // Linha: " + lineNumber.ToString());
							output.WriteLine("  //");
							output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
							output.WriteLine(node.ToFullString());
							output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 04/03/2024-06 ------------");
							output.WriteLine("  //");
						}

						output.Write("'");
					}
					break;

				case SyntaxKind.CharacterLiteralExpression:

					{
						LiteralExpressionSyntax literalExpression = node as LiteralExpressionSyntax;

						try
						{
							if (literalExpression.Token.ValueText.StartsWith("\\ud", StringComparison.OrdinalIgnoreCase))
							{
								output.Write("#$");
								output.Write(literalExpression.Token.ValueText.Substring(3));
							}
							else
							{
								output.Write("'");
								output.Write(literalExpression.Token.ValueText);
								output.Write("'");
							}
                        }
                        catch
						{
							output.WriteLine();
							output.WriteLine("  //");
							output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                            output.WriteLine("  // Node.Kind: " + node.Kind().ToString());
                            output.WriteLine("  // Type: " + node.GetType().Name);
                            output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
							output.WriteLine("  // Posição: " + node.FullSpan.ToString());
							output.WriteLine("  // Linha: " + lineNumber.ToString());
							output.WriteLine("  //");
							output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
							output.WriteLine(node.ToFullString());
							output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 04/03/2024-06 ------------");
							output.WriteLine("  //");
						}

						output.Write("'");
					}
                    break;


                    break;

				case SyntaxKind.NumericLiteralExpression:
					GenerateNumericLiteralExpressionSyntax(node);
					break;

				case SyntaxKind.NullLiteralExpression:
					output.Write("nil");
					break;

				case SyntaxKind.LogicalNotExpression:
					output.Write("not ");
					GenerateExpressionSyntax(((PrefixUnaryExpressionSyntax)node).Operand);
					break;

				case SyntaxKind.EqualsExpression:
				case SyntaxKind.LessThanExpression:
				case SyntaxKind.LogicalAndExpression:
				case SyntaxKind.NotEqualsExpression:
				case SyntaxKind.GreaterThanOrEqualExpression:
				case SyntaxKind.GreaterThanExpression:
				case SyntaxKind.LogicalOrExpression:
				case SyntaxKind.SubtractExpression:
				case SyntaxKind.DivideExpression:
				case SyntaxKind.BitwiseAndExpression:
				case SyntaxKind.BitwiseOrExpression:
				case SyntaxKind.MultiplyExpression:
				case SyntaxKind.AddExpression:
				case SyntaxKind.AsExpression:
				case SyntaxKind.IsExpression:
				case SyntaxKind.RightShiftExpression:
				case SyntaxKind.LeftShiftExpression:
				case SyntaxKind.LessThanOrEqualExpression:
				case SyntaxKind.ModuloExpression:
				case SyntaxKind.ExclusiveOrExpression:
					GenerateBinaryExpressionSyntax((BinaryExpressionSyntax)node);
					break;

				case SyntaxKind.BitwiseNotExpression:
					output.Write(" not ");


					var item = (PrefixUnaryExpressionSyntax)node;
					
					GenerateExpressionSyntax(item.Operand);
					break;

				case SyntaxKind.CoalesceExpression:
					output.Write(node.ToString());
					break;

				case SyntaxKind.TypeOfExpression:
					GenerateTypeOfExpressionSyntax((TypeOfExpressionSyntax)node);
					break;

				case SyntaxKind.CastExpression:
					GenerateCastExpressionSyntax((CastExpressionSyntax)node);
					break;

				case SyntaxKind.ConditionalExpression:
					GenerateConditionalExpressionSyntax((ConditionalExpressionSyntax)node);
					break;

				case SyntaxKind.PredefinedType:
					GeneratePredefinedTypeSyntax((PredefinedTypeSyntax)node);
					break;

				case SyntaxKind.ObjectCreationExpression:
					GenerateObjectCreationExpressionSyntax((ObjectCreationExpressionSyntax)node);
					break;

				case SyntaxKind.ParenthesizedExpression:
					GenerateParenthesizedExpressionSyntax((ParenthesizedExpressionSyntax)node);
					break;

				case SyntaxKind.ElementAccessExpression:
					GenerateElementAccessExpressionSyntax((ElementAccessExpressionSyntax)node);
					break;

				case SyntaxKind.AddAssignmentExpression:
				case SyntaxKind.SimpleAssignmentExpression:
				case SyntaxKind.SubtractAssignmentExpression:
				case SyntaxKind.AndAssignmentExpression:
				case SyntaxKind.OrAssignmentExpression:
				case SyntaxKind.DivideAssignmentExpression:
				case SyntaxKind.MultiplyAssignmentExpression:
				case SyntaxKind.ModuloAssignmentExpression:
				case SyntaxKind.ExclusiveOrAssignmentExpression:
				case SyntaxKind.LeftShiftAssignmentExpression:
				case SyntaxKind.RightShiftAssignmentExpression:
					GenerateAssignmentExpressionSyntax((AssignmentExpressionSyntax)node);
					break;

				case SyntaxKind.PostIncrementExpression:
				case SyntaxKind.PostDecrementExpression:
					GeneratePostfixUnaryExpressionSyntax((PostfixUnaryExpressionSyntax)node);
					break;

				case SyntaxKind.ConditionalAccessExpression:
					GenerateConditionalAccessExpressionSyntax((ConditionalAccessExpressionSyntax)node);
					break;

				case SyntaxKind.ThisExpression:
					GenerateThisExpressionSyntax((ThisExpressionSyntax)node);
					break;

				case SyntaxKind.QualifiedName:
					GenerateQualifiedNameSyntax((QualifiedNameSyntax)node);
					break;

					
				case SyntaxKind.MemberBindingExpression:
					GenerateMemberBindingExpressionSyntax((MemberBindingExpressionSyntax)node);
					break;

				case SyntaxKind.GenericName:
					output.Write(node.ToString());
					break;

				case SyntaxKind.SizeOfExpression:
					GenerateSizeOfExpressionSyntax((SizeOfExpressionSyntax)node);
					break;

				case SyntaxKind.DefaultExpression:
					GenerateDefaultExpressionSyntax((DefaultExpressionSyntax)node);
					break;

				case SyntaxKind.PreIncrementExpression:
				case SyntaxKind.PreDecrementExpression:
					GeneratePrefixUnaryExpressionSyntax((PrefixUnaryExpressionSyntax)node);
					break;


				case SyntaxKind.ArrayCreationExpression:
					GenerateArrayCreationExpressionSyntax((ArrayCreationExpressionSyntax)node);
					break;

				case SyntaxKind.ArrayType:
					GenerateArrayTypeSyntax((ArrayTypeSyntax)node);
					break;

				case SyntaxKind.AnonymousMethodExpression:
					GenerateAnonymousMethodExpressionSyntax((AnonymousMethodExpressionSyntax)node);
					break;

				case SyntaxKind.PointerType:
					GeneratePointerTypeSyntax((PointerTypeSyntax)node);
					break;

				case SyntaxKind.ParenthesizedLambdaExpression:
					GenerateParenthesizedLambdaExpressionSyntax((ParenthesizedLambdaExpressionSyntax)node);
					break;

                case SyntaxKind.SimpleLambdaExpression:
                    GenerateSimpleLambdaExpressionSyntax((SimpleLambdaExpressionSyntax)node);
                    break;

                case SyntaxKind.PointerMemberAccessExpression:

					if (node is MemberAccessExpressionSyntax)
					{
						MemberAccessExpressionSyntax memberAccessExpressionSyntax = (MemberAccessExpressionSyntax)node;

						GenerateExpressionSyntax(memberAccessExpressionSyntax.Expression);
						output.Write("^.");

						output.Write(CodeGenUtils.CreateEscapedIdentifier(memberAccessExpressionSyntax.Name.Identifier.ValueText));
					} 
					else
                    {
						throw new NotImplementedException();
                    }

					break;

                case SyntaxKind.SuppressNullableWarningExpression:

                    if (node is PostfixUnaryExpressionSyntax postfixUnaryExpressionSyntax)
                    {
                        output.Write(postfixUnaryExpressionSyntax.Operand.ToFullString());
                    }
                    else
                    {
                        throw new NotImplementedException();
                    }

                    break;

                case SyntaxKind.NullableType:

                    if (node is NullableTypeSyntax nullableTypeSyntax)
                    {
						
                        // output.Write("Nullable<" + CSharpToObjectPascalType(nullableTypeSyntax.ElementType) + ">");
                        output.Write(CSharpToObjectPascalType(nullableTypeSyntax.ElementType));
                    }
                    else
                    {
                        throw new NotImplementedException();
                    }

                    break;

                case SyntaxKind.CoalesceAssignmentExpression:


                    if (node is AssignmentExpressionSyntax assignmentExpressionSyntax)
                    {
                        GenerateCoalesceAssignmentExpressionSyntax(assignmentExpressionSyntax);
                    }
                    else
                    {
                        throw new NotImplementedException();
                    }

                    break;

				case SyntaxKind.ThrowExpression:


					if (node is ThrowExpressionSyntax throwExpressionSyntax)
					{
						GenerateThrowExpressionSyntax(throwExpressionSyntax);
					}
					else
					{
						throw new NotImplementedException();
					}

					break;

                case SyntaxKind.IsPatternExpression:


                    if (node is IsPatternExpressionSyntax isPatternExpressionSyntax)
                    {
                        GenerateIsPatternExpressionSyntax(isPatternExpressionSyntax);
                    }
                    else
                    {
                        throw new NotImplementedException();
                    }

                    break;


                case SyntaxKind.InterpolatedStringExpression:


                    if (node is InterpolatedStringExpressionSyntax interpolatedStringExpressionSyntax)
                    {
                        GenerateInterpolatedStringExpressionSyntax(interpolatedStringExpressionSyntax);
                    }
                    else
                    {
                        throw new NotImplementedException();
                    }

                    break;
				case SyntaxKind.UnaryPlusExpression:
					GeneratePrefixUnaryExpressionSyntax((PrefixUnaryExpressionSyntax)node);
					break;
				case SyntaxKind.UnaryMinusExpression:
					GeneratePrefixUnaryExpressionSyntax((PrefixUnaryExpressionSyntax)node);
					break;
                case SyntaxKind.ArrayInitializerExpression:
                    GenerateArrayInitializerExpressionSyntax((InitializerExpressionSyntax)node);
                    break;

                case SyntaxKind.ImplicitObjectCreationExpression:
                    GenerateImplicitObjectCreationExpressionSyntax((ImplicitObjectCreationExpressionSyntax)node);
                    break;

                case SyntaxKind.PointerIndirectionExpression:
                    GeneratePrefixUnaryExpressionSyntax((PrefixUnaryExpressionSyntax)node);
                    break;

                case SyntaxKind.CheckedExpression:
                    GenerateCheckedExpressionSyntax((CheckedExpressionSyntax)node);
                    break;

                case SyntaxKind.SwitchExpression:
                    GenerateSwitchExpressionSyntax((SwitchExpressionSyntax)node);
                    break;

                case SyntaxKind.AddressOfExpression:
                    GeneratePrefixUnaryExpressionSyntax((PrefixUnaryExpressionSyntax)node);
                    break;

                case SyntaxKind.CollectionExpression:
                    GenerateCollectionExpressionSyntax((CollectionExpressionSyntax)node);
                    break;

                case SyntaxKind.StackAllocArrayCreationExpression:
                    GenerateStackAllocArrayCreationExpressionSyntax((StackAllocArrayCreationExpressionSyntax)node);
                    break;

                case SyntaxKind.DefaultLiteralExpression:
                    GenerateLiteralExpressionSyntax((LiteralExpressionSyntax)node);
                    break;

                case SyntaxKind.TupleExpression:
                    GenerateTupleExpressionSyntax((TupleExpressionSyntax)node);
                    break;
                case SyntaxKind.DeclarationExpression:
                    GenerateDeclarationExpressionSyntax((DeclarationExpressionSyntax)node);
                    break;
                case SyntaxKind.UncheckedExpression:
                    GenerateUncheckedExpressionSyntax((CheckedExpressionSyntax)node);
                    break;
                case SyntaxKind.RefExpression:
                    GenerateRefExpressionSyntaxSyntax((RefExpressionSyntax)node);
                    break;
                case SyntaxKind.FunctionPointerType:
                    GenerateFunctionPointerTypeSyntax((FunctionPointerTypeSyntax)node);
                    break;
                case SyntaxKind.Utf8StringLiteralExpression:
                    GenerateLiteralExpressionSyntax((LiteralExpressionSyntax)node);
                    break;
                case SyntaxKind.AliasQualifiedName:
                    GenerateAliasQualifiedNameSyntax((AliasQualifiedNameSyntax)node);
                    break;
                case SyntaxKind.ImplicitElementAccess:
                    GenerateImplicitElementAccessSyntax((ImplicitElementAccessSyntax)node);
                    break;
                case SyntaxKind.ComplexElementInitializerExpression:
                    GenerateInitializerExpressionSyntax((InitializerExpressionSyntax)node);
                    break;
                case SyntaxKind.OmittedArraySizeExpression:
                    GenerateOmittedArraySizeExpressionSyntax((OmittedArraySizeExpressionSyntax)node);
                    break;
                case SyntaxKind.ElementBindingExpression:
                    GenerateElementBindingExpressionSyntax((ElementBindingExpressionSyntax)node);
                    break;
                case SyntaxKind.ImplicitArrayCreationExpression:
                    GenerateImplicitArrayCreationExpressionSyntax((ImplicitArrayCreationExpressionSyntax)node);
                    break;


                default:

					output.WriteLine();
					output.WriteLine("  //");
					output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                    output.WriteLine("  // Node.Kind: " + node.Kind().ToString());
                    output.WriteLine("  // Type: " + node.GetType().Name);
                    output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
					output.WriteLine("  // Posição: " + node.FullSpan.ToString());
					output.WriteLine("  // Linha: " + lineNumber.ToString());
					output.WriteLine("  //");
					output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
					output.WriteLine(node.ToFullString());
					output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-01 ------------");
					output.WriteLine("  //");

					break;
			}


		}

        private void GenerateImplicitArrayCreationExpressionSyntax(ImplicitArrayCreationExpressionSyntax node)
        {
            output.Write(node.ToString());
            output.Write("{não implementado[GenerateImplicitArrayCreationExpressionSyntax]}");
        }

        private void GenerateElementBindingExpressionSyntax(ElementBindingExpressionSyntax node)
        {
            output.Write(node.ToString());
            output.Write("{não implementado[GenerateElementBindingExpressionSyntax]}");
        }

        private void GenerateOmittedArraySizeExpressionSyntax(OmittedArraySizeExpressionSyntax node)
        {
            output.Write(node.ToString());
            output.Write("{não implementado[GenerateOmittedArraySizeExpressionSyntax]}");
        }

        private void GenerateInitializerExpressionSyntax(InitializerExpressionSyntax node)
        {
            output.Write(node.ToString());
            output.Write("{não implementado[GenerateInitializerExpressionSyntax]}");
        }

        private void GenerateImplicitElementAccessSyntax(ImplicitElementAccessSyntax node)
        {
            output.Write(node.ToString());
            output.Write("{não implementado[GenerateImplicitElementAccessSyntax]}");
        }

        private void GenerateAliasQualifiedNameSyntax(AliasQualifiedNameSyntax node)
        {
            output.Write(node.ToString());
            output.Write("{não implementado[GenerateAliasQualifiedNameSyntax]}");
        }

        private void GenerateFunctionPointerTypeSyntax(FunctionPointerTypeSyntax node)
        {
            output.Write(node.ToString());
            output.Write("{não implementado[GenerateFunctionPointerTypeSyntax]}");
        }

        private void GenerateRefExpressionSyntaxSyntax(RefExpressionSyntax node)
        {
			GenerateExpressionSyntax(node.Expression);
        }

        private void GenerateDeclarationExpressionSyntax(DeclarationExpressionSyntax node)
        {
            VariableDesignationSyntax variableDesignationSyntax = node.Designation;
            if (variableDesignationSyntax.IsKind(SyntaxKind.SingleVariableDesignation))
            {
                SingleVariableDesignationSyntax singleVariableDesignationSyntax = (SingleVariableDesignationSyntax)variableDesignationSyntax;

                var variableName = CodeGenUtils.CreateEscapedIdentifier(singleVariableDesignationSyntax.Identifier.ValueText);
                output.Write(variableName);
            }
			else
			{
                var kind = node.Kind();
                FileLinePositionSpan span = node.SyntaxTree.GetLineSpan(node.Span);
                int lineNumber = span.StartLinePosition.Line + 1;

                output.WriteLine();
                output.WriteLine("  //");
                output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                output.WriteLine("  // Kind: " + node.Kind().ToString());
                output.WriteLine("  // Type: " + node.GetType().Name);
                output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                output.WriteLine("  // Linha: " + lineNumber.ToString());
                output.WriteLine("  //");
                output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                output.WriteLine(node.ToFullString());
                output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 13/04/2024-1 ------------");
                output.WriteLine("  //");

            }

        }

        private void GenerateTupleExpressionSyntax(TupleExpressionSyntax node)
        {
			output.Write(node.ToFullString());
        }

        private void GenerateLiteralExpressionSyntax(LiteralExpressionSyntax node)
        {
			output.Write(node.Token.ToString());
            output.Write("{não implementado[GenerateLiteralExpressionSyntax]}");

        }

        private void GenerateStackAllocArrayCreationExpressionSyntax(StackAllocArrayCreationExpressionSyntax node)
        {
            output.Write("StackAlloc(");

			if (node.Initializer != null)
			{
				foreach (ExpressionSyntax expressionSyntax in node.Initializer.Expressions)
				{
					GenerateExpressionSyntax(expressionSyntax);

					if (!expressionSyntax.Equals(node.Initializer.Expressions.Last()))
					{
						output.Write(", ");
					}
				}
			}

            if (node.Type != null)
			{
                if (node.Type.IsKind(SyntaxKind.ArrayType))
                {
                    ArrayTypeSyntax arrayTypeSyntax = (ArrayTypeSyntax)node.Type;

					output.Write(arrayTypeSyntax.RankSpecifiers.First().Sizes.ToString());
                    output.Write(" * SizeOf(");
                    output.Write(CSharpToObjectPascalType(arrayTypeSyntax.ElementType));
                    output.Write(")");
                }
                else
                {
                    output.Write("SizeOf(");
                    output.Write(CSharpToObjectPascalType(node.Type));
                    output.Write(")");
                }

            }

            output.Write(")");
        }

        private void GenerateCollectionExpressionSyntax(CollectionExpressionSyntax node)
        {


			SeparatedSyntaxList<CollectionElementSyntax> collectionElements = node.Elements;

			if (node.Elements.Count() == 0)
			{
				output.Write("nil");
				return;
			}



            output.Write("[");
            foreach (CollectionElementSyntax collectionElement in collectionElements) 
			{
				output.Write(collectionElement.ToString());
                output.Write(",");
            }
            output.Write("]");
        }

        private void GenerateSwitchExpressionSyntax(SwitchExpressionSyntax node)
        {
			if (node.Parent.IsKind(SyntaxKind.EqualsValueClause))
			{
				EqualsValueClauseSyntax equalsValueClauseSyntax = (EqualsValueClauseSyntax)node.Parent;
				if (equalsValueClauseSyntax.Parent.IsKind(SyntaxKind.VariableDeclarator))
				{
                    VariableDeclaratorSyntax variableDeclaratorSyntax = (VariableDeclaratorSyntax)equalsValueClauseSyntax.Parent;
                    VariableDeclarationSyntax variableDeclarationSyntax = (VariableDeclarationSyntax)variableDeclaratorSyntax.Parent;

                    output.Write("(function(): ");
                    output.Write(CSharpToObjectPascalType(variableDeclarationSyntax.Type));
                    output.WriteLine();
                    output.WriteLine("begin");
                    output.Indent++;

                    output.Write("case (");
                    GenerateExpressionSyntax(node.GoverningExpression);
                    output.WriteLine(") of");
                    output.Indent++;

                    foreach (SwitchExpressionArmSyntax switchExpressionArm in node.Arms)
					{
						if (switchExpressionArm.WhenClause == null && switchExpressionArm.Pattern != null && switchExpressionArm.Expression != null)
						{
                            
							if (switchExpressionArm.Pattern.IsKind(SyntaxKind.DiscardPattern))
							{
                                output.Indent--;
                                output.WriteLine("else");
                                output.Indent++;

                                output.Write("Result := ");
                                GenerateExpressionSyntax(switchExpressionArm.Expression);
                                output.WriteLine(";");
                            }
                            else
                            {
								if (switchExpressionArm.Pattern.IsKind(SyntaxKind.OrPattern))
                                {
                                    output.WriteLine(switchExpressionArm.Pattern.ToString().Replace(" or ", ", ") + ":");
                                }
                                else
								{
                                    output.WriteLine(switchExpressionArm.Pattern.ToString() + ":");
                                }

                                output.Indent++;
                                output.Write("Result := ");
                                GenerateExpressionSyntax(switchExpressionArm.Expression);
                                output.WriteLine(";");
                                output.Indent--;
                            }
                        }
						else
						{
                            var declaration = switchExpressionArm;
                            FileLinePositionSpan span = declaration.SyntaxTree.GetLineSpan(declaration.Span);
                            int lineNumber = span.StartLinePosition.Line + 1;

                            output.WriteLine();
                            output.WriteLine("  //");
                            output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + declaration.Kind().ToString());
                            output.WriteLine("  // Kind: " + declaration.Kind().ToString());
                            output.WriteLine("  // Type: " + declaration.GetType().Name);
                            output.WriteLine("  // Arquivo: " + declaration.SyntaxTree.FilePath);
                            output.WriteLine("  // Posição: " + declaration.FullSpan.ToString());
                            output.WriteLine("  // Linha: " + lineNumber.ToString());
                            output.WriteLine("  //");
                            output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                            output.WriteLine(declaration.ToFullString());
                            output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-06 ------------");
                            output.WriteLine("  //");
                        }
                    }

                    output.Indent--;
                    output.WriteLine("end;");

                    output.Indent--;
                    output.Write("end)");
                    output.Write("()");
                }
				else
				{
					var declaration = equalsValueClauseSyntax.Parent;
                    FileLinePositionSpan span = declaration.SyntaxTree.GetLineSpan(declaration.Span);
                    int lineNumber = span.StartLinePosition.Line + 1;

                    output.WriteLine();
                    output.WriteLine("  //");
                    output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + declaration.Kind().ToString());
                    output.WriteLine("  // Kind: " + declaration.Kind().ToString());
                    output.WriteLine("  // Type: " + declaration.GetType().Name);
                    output.WriteLine("  // Arquivo: " + declaration.SyntaxTree.FilePath);
                    output.WriteLine("  // Posição: " + declaration.FullSpan.ToString());
                    output.WriteLine("  // Linha: " + lineNumber.ToString());
                    output.WriteLine("  //");
                    output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                    output.WriteLine(declaration.ToFullString());
                    output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-04 ------------");
                    output.WriteLine("  //");
                }
            }


            else if (node.Parent.IsKind(SyntaxKind.ReturnStatement))
            {
                ReturnStatementSyntax returnStatementSyntax = (ReturnStatementSyntax)node.Parent;
                if (returnStatementSyntax.Parent.IsKind(SyntaxKind.Block))
                {
                    BlockSyntax blockSyntax = (BlockSyntax)returnStatementSyntax.Parent;

					if (blockSyntax.Parent.IsKind(SyntaxKind.MethodDeclaration))
					{
                        MethodDeclarationSyntax methodDeclarationSyntax = (MethodDeclarationSyntax)blockSyntax.Parent;

						output.Write("(function(): ");
						output.Write(CSharpToObjectPascalType(methodDeclarationSyntax.ReturnType));
						output.WriteLine();
						output.WriteLine("begin");
						output.Indent++;

						output.Write("case (");
						GenerateExpressionSyntax(node.GoverningExpression);
						output.WriteLine(") of");
						output.Indent++;

						foreach (SwitchExpressionArmSyntax switchExpressionArm in node.Arms)
						{
							if (switchExpressionArm.WhenClause == null && switchExpressionArm.Pattern != null && switchExpressionArm.Expression != null)
							{

								if (switchExpressionArm.Pattern.IsKind(SyntaxKind.DiscardPattern))
								{
									output.Indent--;
									output.WriteLine("else");
									output.Indent++;

									if (!switchExpressionArm.Expression.IsKind(SyntaxKind.ThrowExpression))
									{
                                        output.Write("Result := ");
                                    }

                                    GenerateExpressionSyntax(switchExpressionArm.Expression);
									output.WriteLine(";");
								}
								else
								{
									if (switchExpressionArm.Pattern.IsKind(SyntaxKind.OrPattern))
									{
										output.WriteLine(switchExpressionArm.Pattern.ToString().Replace(" or ", ", ") + ":");
									}
									else
									{
										output.WriteLine(switchExpressionArm.Pattern.ToString() + ":");
									}

									output.Indent++;
									output.Write("Result := ");
									GenerateExpressionSyntax(switchExpressionArm.Expression);
									output.WriteLine(";");
									output.Indent--;
								}
							}
							else
							{
								var declaration = switchExpressionArm;
								FileLinePositionSpan span = declaration.SyntaxTree.GetLineSpan(declaration.Span);
								int lineNumber = span.StartLinePosition.Line + 1;

								output.WriteLine();
								output.WriteLine("  //");
								output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + declaration.Kind().ToString());
								output.WriteLine("  // Kind: " + declaration.Kind().ToString());
								output.WriteLine("  // Type: " + declaration.GetType().Name);
								output.WriteLine("  // Arquivo: " + declaration.SyntaxTree.FilePath);
								output.WriteLine("  // Posição: " + declaration.FullSpan.ToString());
								output.WriteLine("  // Linha: " + lineNumber.ToString());
								output.WriteLine("  //");
								output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
								output.WriteLine(declaration.ToFullString());
								output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-10 ------------");
								output.WriteLine("  //");
							}
						}

						output.Indent--;
						output.WriteLine("end;");

						output.Indent--;
						output.Write("end)");
						output.Write("()");
					}
					else
					{
                        var declaration = blockSyntax.Parent.Parent;
                        FileLinePositionSpan span = declaration.SyntaxTree.GetLineSpan(declaration.Span);
                        int lineNumber = span.StartLinePosition.Line + 1;

                        output.WriteLine();
                        output.WriteLine("  //");
                        output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + declaration.Kind().ToString());
                        output.WriteLine("  // Kind: " + declaration.Kind().ToString());
                        output.WriteLine("  // Type: " + declaration.GetType().Name);
                        output.WriteLine("  // Arquivo: " + declaration.SyntaxTree.FilePath);
                        output.WriteLine("  // Posição: " + declaration.FullSpan.ToString());
                        output.WriteLine("  // Linha: " + lineNumber.ToString());
                        output.WriteLine("  //");
                        output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                        output.WriteLine(declaration.ToFullString());
                        output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-12 ------------");
                        output.WriteLine("  //");
                    }
                }
                else
                {
                    var declaration = returnStatementSyntax.Parent;
                    FileLinePositionSpan span = declaration.SyntaxTree.GetLineSpan(declaration.Span);
                    int lineNumber = span.StartLinePosition.Line + 1;

                    output.WriteLine();
                    output.WriteLine("  //");
                    output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + declaration.Kind().ToString());
                    output.WriteLine("  // Kind: " + declaration.Kind().ToString());
                    output.WriteLine("  // Type: " + declaration.GetType().Name);
                    output.WriteLine("  // Arquivo: " + declaration.SyntaxTree.FilePath);
                    output.WriteLine("  // Posição: " + declaration.FullSpan.ToString());
                    output.WriteLine("  // Linha: " + lineNumber.ToString());
                    output.WriteLine("  //");
                    output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                    output.WriteLine(declaration.ToFullString());
                    output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-11 ------------");
                    output.WriteLine("  //");
                }
            }
            else
            {
                var declaration = node.Parent;
                FileLinePositionSpan span = declaration.SyntaxTree.GetLineSpan(declaration.Span);
                int lineNumber = span.StartLinePosition.Line + 1;

                output.WriteLine();
                output.WriteLine("  //");
                output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + declaration.Kind().ToString());
                output.WriteLine("  // Kind: " + declaration.Kind().ToString());
                output.WriteLine("  // Type: " + declaration.GetType().Name);
                output.WriteLine("  // Arquivo: " + declaration.SyntaxTree.FilePath);
                output.WriteLine("  // Posição: " + declaration.FullSpan.ToString());
                output.WriteLine("  // Linha: " + lineNumber.ToString());
                output.WriteLine("  //");
                output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                output.WriteLine(declaration.ToFullString());
                output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-05 ------------");
                output.WriteLine("  //");
            }
        }

        private void GenerateCheckedExpressionSyntax(CheckedExpressionSyntax node)
        {
			output.Write("checked(");
			GenerateExpressionSyntax(node.Expression);
            output.Write(")");
        }
        
        private void GenerateUncheckedExpressionSyntax(CheckedExpressionSyntax node)
        {
            output.Write("unchecked(");
            GenerateExpressionSyntax(node.Expression);
            output.Write(")");
        }

        private void GenerateImplicitObjectCreationExpressionSyntax(ImplicitObjectCreationExpressionSyntax node)
        {
			if (node.Parent.IsKind(SyntaxKind.ArrowExpressionClause))
			{
				ArrowExpressionClauseSyntax arrowExpressionClauseSyntax = (ArrowExpressionClauseSyntax)node.Parent;

				if (arrowExpressionClauseSyntax.Parent.IsKind(SyntaxKind.GetAccessorDeclaration))
				{
					AccessorDeclarationSyntax accessorDeclarationSyntax = (AccessorDeclarationSyntax)arrowExpressionClauseSyntax.Parent;

					PropertyDeclarationSyntax propertyDeclarationSyntax = (PropertyDeclarationSyntax)accessorDeclarationSyntax.Parent.Parent;

					output.Write(CSharpToObjectPascalType(propertyDeclarationSyntax.Type));

				}
				else if (arrowExpressionClauseSyntax.Parent.IsKind(SyntaxKind.MethodDeclaration))
				{
					MethodDeclarationSyntax methodDeclaration = (MethodDeclarationSyntax)arrowExpressionClauseSyntax.Parent;

					output.Write(CSharpToObjectPascalType(methodDeclaration.ReturnType));

				}
                else if (arrowExpressionClauseSyntax.Parent.IsKind(SyntaxKind.PropertyDeclaration))
                {
                    PropertyDeclarationSyntax propertyDeclaration = (PropertyDeclarationSyntax)arrowExpressionClauseSyntax.Parent;

                    output.Write(CSharpToObjectPascalType(propertyDeclaration.Type));

                }
                else
                {
					var declaration = arrowExpressionClauseSyntax.Parent;
					var kind = declaration.Kind();
					FileLinePositionSpan span = declaration.SyntaxTree.GetLineSpan(declaration.Span);
					int lineNumber = span.StartLinePosition.Line + 1;

					output.WriteLine();
					output.WriteLine("  //");
					output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
					output.WriteLine("  // Kind: " + declaration.Kind().ToString());
					output.WriteLine("  // Type: " + declaration.GetType().Name);
					output.WriteLine("  // Arquivo: " + declaration.SyntaxTree.FilePath);
					output.WriteLine("  // Posição: " + declaration.FullSpan.ToString());
					output.WriteLine("  // Linha: " + lineNumber.ToString());
					output.WriteLine("  //");
					output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
					output.WriteLine(declaration.ToFullString());
					output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-02 ------------");
					output.WriteLine("  //");
				}
			}
			else if (node.Parent.IsKind(SyntaxKind.EqualsValueClause))
			{
				EqualsValueClauseSyntax equalsValueClauseSyntax = (EqualsValueClauseSyntax)node.Parent;
				if (equalsValueClauseSyntax.Parent.IsKind(SyntaxKind.VariableDeclarator))
				{
					VariableDeclaratorSyntax variableDeclaratorSyntax = (VariableDeclaratorSyntax)equalsValueClauseSyntax.Parent;
					VariableDeclarationSyntax variableDeclarationSyntax = (VariableDeclarationSyntax)variableDeclaratorSyntax.Parent;

					output.Write(CSharpToObjectPascalType(variableDeclarationSyntax.Type));
                }
                else
				{
					var declaration = equalsValueClauseSyntax.Parent;
					var kind = declaration.Kind();
					FileLinePositionSpan span = declaration.SyntaxTree.GetLineSpan(declaration.Span);
					int lineNumber = span.StartLinePosition.Line + 1;

					output.WriteLine();
					output.WriteLine("  //");
					output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
					output.WriteLine("  // Kind: " + declaration.Kind().ToString());
					output.WriteLine("  // Type: " + declaration.GetType().Name);
					output.WriteLine("  // Arquivo: " + declaration.SyntaxTree.FilePath);
					output.WriteLine("  // Posição: " + declaration.FullSpan.ToString());
					output.WriteLine("  // Linha: " + lineNumber.ToString());
					output.WriteLine("  //");
					output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
					output.WriteLine(declaration.ToFullString());
					output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-07 ------------");
					output.WriteLine("  //");
				}
			}
			else
			{
				var declaration = node.Parent;
				var kind = declaration.Kind();
				FileLinePositionSpan span = declaration.SyntaxTree.GetLineSpan(declaration.Span);
				int lineNumber = span.StartLinePosition.Line + 1;

				output.WriteLine();
				output.WriteLine("  //");
				output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
				output.WriteLine("  // Kind: " + declaration.Kind().ToString());
				output.WriteLine("  // Type: " + declaration.GetType().Name);
				output.WriteLine("  // Arquivo: " + declaration.SyntaxTree.FilePath);
				output.WriteLine("  // Posição: " + declaration.FullSpan.ToString());
				output.WriteLine("  // Linha: " + lineNumber.ToString());
				output.WriteLine("  //");
				output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
				output.WriteLine(declaration.ToFullString());
				output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 22-03-2024-03 ------------");
				output.WriteLine("  //");
			}


            output.Write(".Create(");

            GenerateArgumentListSyntax(node.ArgumentList);


            output.Write(")");

            if (node.Initializer != null)
            {
                output.WriteLine(";");
                foreach (ExpressionSyntax expressionSyntax in node.Initializer.Expressions)
                {
                    output.Write("Result.");
                    GenerateExpressionSyntax(expressionSyntax);
                }
            }


        }

        private void GenerateNumericLiteralExpressionSyntax(ExpressionSyntax node)
        {
			LiteralExpressionSyntax numericLiteralExpression = node as LiteralExpressionSyntax;

			string numericLiteralText = numericLiteralExpression.Token.Text;

			if (numericLiteralText.StartsWith("0x", StringComparison.InvariantCultureIgnoreCase))
				numericLiteralText = numericLiteralText.Replace("0x", "$", StringComparison.InvariantCultureIgnoreCase);
			else if (numericLiteralText.StartsWith("0b", StringComparison.InvariantCultureIgnoreCase))
				numericLiteralText = numericLiteralText.Replace("0b", "%", StringComparison.InvariantCultureIgnoreCase);

			if (node.Parent.IsKind(SyntaxKind.UnaryPlusExpression))
				numericLiteralText = "+" + numericLiteralText;
			else if (node.Parent.IsKind(SyntaxKind.UnaryMinusExpression))
				numericLiteralText = "-" + numericLiteralText;

			if (numericLiteralText.EndsWith("UL", StringComparison.InvariantCultureIgnoreCase))
				numericLiteralText = "UInt64(" + numericLiteralText.Replace("UL", "", StringComparison.InvariantCultureIgnoreCase) + ")";
			else if (numericLiteralText.EndsWith("LU", StringComparison.InvariantCultureIgnoreCase))
				numericLiteralText = "UInt64(" + numericLiteralText.Replace("LU", "", StringComparison.InvariantCultureIgnoreCase) + ")";
			else if (numericLiteralText.EndsWith("L", StringComparison.InvariantCultureIgnoreCase))
				numericLiteralText = "Int64(" + numericLiteralText.Replace("L", "", StringComparison.InvariantCultureIgnoreCase) + ")";
			else if (numericLiteralText.EndsWith("U", StringComparison.InvariantCultureIgnoreCase))
				numericLiteralText = "UInt32(" + numericLiteralText.Replace("U", "", StringComparison.InvariantCultureIgnoreCase) + ")";
			else if (numericLiteralText.EndsWith("F", StringComparison.InvariantCultureIgnoreCase) && !numericLiteralText.StartsWith("$", StringComparison.InvariantCultureIgnoreCase))
				numericLiteralText = "Single(" + numericLiteralText.Replace("F", "", StringComparison.InvariantCultureIgnoreCase) + ")";
			else if (numericLiteralText.EndsWith("D", StringComparison.InvariantCultureIgnoreCase) && !numericLiteralText.StartsWith("$", StringComparison.InvariantCultureIgnoreCase))
				numericLiteralText = "Double(" + numericLiteralText.Replace("D", "", StringComparison.InvariantCultureIgnoreCase) + ")";
			else if (numericLiteralText.EndsWith("M", StringComparison.InvariantCultureIgnoreCase))
				numericLiteralText = "Decimal(" + numericLiteralText.Replace("M", "", StringComparison.InvariantCultureIgnoreCase) + ")";

			output.Write(numericLiteralText);
		}

		private void GenerateInterpolatedStringExpressionSyntax(InterpolatedStringExpressionSyntax interpolatedStringExpressionSyntax)
        {
			SyntaxList<InterpolatedStringContentSyntax> Contents = interpolatedStringExpressionSyntax.Contents;

            output.Write("'");

            foreach (InterpolatedStringContentSyntax item in Contents)
            {

				if (item.ToFullString().StartsWith("{") && item.ToFullString().EndsWith("}"))
				{
					var str = item.ToFullString().Substring(1, item.ToFullString().Length - 2);

					str = str + ".ToString()";

					output.Write("' + ");
                    output.Write(str);
                    output.Write(" + '");
                }
                else
                {
					var str = item.ToFullString();
					str = str.Replace(@"{{", "{");
					str = str.Replace(@"}}", "}");

					output.Write(str);
				}
			}

            output.Write("'");

            
        }

        private void GenerateIsPatternExpressionSyntax(IsPatternExpressionSyntax isPatternExpressionSyntax)
        {
			var node = isPatternExpressionSyntax;
            var kind = node.Kind();
            FileLinePositionSpan span = node.SyntaxTree.GetLineSpan(node.Span);
            int lineNumber = span.StartLinePosition.Line + 1;



			if (isPatternExpressionSyntax.Pattern.IsKind(SyntaxKind.ConstantPattern))
			{
				if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.IdentifierName))
				{
					GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);

                    ConstantPatternSyntax constantPatternSyntax = (ConstantPatternSyntax)isPatternExpressionSyntax.Pattern;

					if (constantPatternSyntax.Expression.IsKind(SyntaxKind.NullLiteralExpression))
					{
						LiteralExpressionSyntax literalExpressionSyntax = (LiteralExpressionSyntax)constantPatternSyntax.Expression;

						if (literalExpressionSyntax.Token.IsKind(SyntaxKind.NullKeyword))
						{
                            output.Write(" = nil");
                        }
                        else
                        {
                            throw new NotImplementedException();
                        }
                    }
                    else
                    {

                        output.WriteLine();
                        output.WriteLine("  //");
                        output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                        output.WriteLine("  // Kind: " + node.Kind().ToString());
                        output.WriteLine("  // Type: " + node.GetType().Name);
                        output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                        output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                        output.WriteLine("  // Linha: " + lineNumber.ToString());
                        output.WriteLine("  //");
                        output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                        output.WriteLine(node.ToFullString());
                        output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 222 22/02/2024 ------------");
                        output.WriteLine("  //");
                        //throw new NotImplementedException();
                    }


                }
				else if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.SimpleMemberAccessExpression))
				{
                    GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);

                    ConstantPatternSyntax ConstantPatternSyntax = (ConstantPatternSyntax)isPatternExpressionSyntax.Pattern;

                    if (ConstantPatternSyntax.Expression.IsKind(SyntaxKind.NullLiteralExpression))
                    {
                        LiteralExpressionSyntax literalExpressionSyntax = (LiteralExpressionSyntax)ConstantPatternSyntax.Expression;

                        if (literalExpressionSyntax.Token.IsKind(SyntaxKind.NullKeyword))
                        {
                            output.Write(" = nil");
                        }
                        else
                        {
                            throw new NotImplementedException();
                        }
                    }
                    else if (ConstantPatternSyntax.Expression.IsKind(SyntaxKind.FalseLiteralExpression))
                    {
                        LiteralExpressionSyntax literalExpressionSyntax = (LiteralExpressionSyntax)ConstantPatternSyntax.Expression;

                        if (literalExpressionSyntax.Token.IsKind(SyntaxKind.FalseKeyword))
                        {
                            output.Write(" = False");
                        }
                        else
                        {
                            throw new NotImplementedException();
                        }
                    }
                    else if (ConstantPatternSyntax.Expression.IsKind(SyntaxKind.TrueLiteralExpression))
                    {
                        LiteralExpressionSyntax literalExpressionSyntax = (LiteralExpressionSyntax)ConstantPatternSyntax.Expression;

                        if (literalExpressionSyntax.Token.IsKind(SyntaxKind.TrueKeyword))
                        {
                            output.Write(" = True");
                        }
                        else
                        {
                            output.WriteLine();
                            output.WriteLine("  //");
                            output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                            output.WriteLine("  // Kind: " + node.Kind().ToString());
                            output.WriteLine("  // Type: " + node.GetType().Name);
                            output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                            output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                            output.WriteLine("  // Linha: " + lineNumber.ToString());
                            output.WriteLine("  //");
                            output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                            output.WriteLine(node.ToFullString());
                            output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 04/03/2024-1 ------------");
                            output.WriteLine("  //");


                            //throw new NotImplementedException();
                        }
                    }
                    else
                    {
                        output.WriteLine();
                        output.WriteLine("  //");
                        output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                        output.WriteLine("  // Kind: " + node.Kind().ToString());
                        output.WriteLine("  // Type: " + node.GetType().Name);
                        output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                        output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                        output.WriteLine("  // Linha: " + lineNumber.ToString());
                        output.WriteLine("  //");
                        output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                        output.WriteLine(node.ToFullString());
                        output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 04/03/2024-2 ------------");
                        output.WriteLine("  //");


                        //throw new NotImplementedException();
                    }


                }
                else if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.InvocationExpression))
				{
                    GenerateInvocationExpressionSyntax((InvocationExpressionSyntax)isPatternExpressionSyntax.Expression);
                    output.WriteLine("NOVO-ERRO-01");
                }
                else
                {

					output.WriteLine();
					output.WriteLine("  //");
					output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                    output.WriteLine("  // Kind: " + node.Kind().ToString());
                    output.WriteLine("  // Type: " + node.GetType().Name);
                    output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
					output.WriteLine("  // Posição: " + node.FullSpan.ToString());
					output.WriteLine("  // Linha: " + lineNumber.ToString());
					output.WriteLine("  //");
					output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
					output.WriteLine(node.ToFullString());
					output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 2 ------------");
					output.WriteLine("  //");


					//throw new NotImplementedException();
                }
            }
            else if (isPatternExpressionSyntax.Pattern.IsKind(SyntaxKind.NotPattern))
			{

				if (isPatternExpressionSyntax.Expression.Kind() == SyntaxKind.IdentifierName || isPatternExpressionSyntax.Expression.Kind() == SyntaxKind.SimpleMemberAccessExpression)
                {
					GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);

                    UnaryPatternSyntax unaryPatternSyntax = (UnaryPatternSyntax)isPatternExpressionSyntax.Pattern;

					if (unaryPatternSyntax.Kind() == SyntaxKind.NotPattern)
					{
                        output.Write(" <> ");

						if (unaryPatternSyntax.Pattern.IsKind(SyntaxKind.ConstantPattern))
						{

                            ConstantPatternSyntax constantPatternSyntax = (ConstantPatternSyntax)unaryPatternSyntax.Pattern;

							if (constantPatternSyntax.Expression.IsKind(SyntaxKind.IdentifierName))
							{
                                IdentifierNameSyntax identifierNameSyntax = (IdentifierNameSyntax)constantPatternSyntax.Expression;

                                output.Write(CSharpToObjectPascalType(identifierNameSyntax));
                          //      output.Write(identifierNameSyntax.ToFullString());
                            }
                            else if (constantPatternSyntax.Expression.IsKind(SyntaxKind.NullLiteralExpression))
                            {
                                LiteralExpressionSyntax literalExpressionSyntax = (LiteralExpressionSyntax)constantPatternSyntax.Expression;

                                if (literalExpressionSyntax.Token.IsKind(SyntaxKind.NullKeyword))
                                {
                                    output.Write("nil");
                                }
                                else
                                {
                                    throw new NotImplementedException();
                                }
                            }
                            else
                            {
                                var kind2 = isPatternExpressionSyntax.Kind();
                                FileLinePositionSpan span2 = node.SyntaxTree.GetLineSpan(isPatternExpressionSyntax.Span);
                                int lineNumber2 = span2.StartLinePosition.Line + 1;

                                output.WriteLine();
                                output.WriteLine("  //");
                                output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind2.ToString());
                                output.WriteLine("  // Kind: " + node.Kind().ToString());
                                output.WriteLine("  // Type: " + node.GetType().Name);
                                output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                                output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                                output.WriteLine("  // Linha: " + lineNumber2.ToString());
                                output.WriteLine("  //");
                                output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                                output.WriteLine(node.ToFullString());
                                output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 5-1 ------------");
                                output.WriteLine("  //");
                            }

                        }
                        else if (unaryPatternSyntax.Pattern.IsKind(SyntaxKind.DeclarationPattern))
                        {

                            DeclarationPatternSyntax declarationPatternSyntax = (DeclarationPatternSyntax)unaryPatternSyntax.Pattern;

                            if (declarationPatternSyntax.Designation.IsKind(SyntaxKind.SingleVariableDesignation))
                            {
                                SingleVariableDesignationSyntax singleVariableDesignationSyntax = (SingleVariableDesignationSyntax)declarationPatternSyntax.Designation;

                                output.Write(singleVariableDesignationSyntax.ToString());
                                output.Write(": ");
                            }


                            if (declarationPatternSyntax.Type.IsKind(SyntaxKind.IdentifierName))
                            {
                                IdentifierNameSyntax identifierNameSyntax = (IdentifierNameSyntax)declarationPatternSyntax.Type;
                                output.Write(CSharpToObjectPascalType(identifierNameSyntax));
                               // output.Write(identifierNameSyntax.ToString());
                            }

                        }
                        else
                        {

                            var kind2 = isPatternExpressionSyntax.Kind();
                            FileLinePositionSpan span2 = node.SyntaxTree.GetLineSpan(isPatternExpressionSyntax.Span);
                            int lineNumber2 = span2.StartLinePosition.Line + 1;

                            output.WriteLine();
                            output.WriteLine("  //");
                            output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind2.ToString());
                            output.WriteLine("  // Kind: " + node.Kind().ToString());
                            output.WriteLine("  // Type: " + node.GetType().Name);
                            output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                            output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                            output.WriteLine("  // Linha: " + lineNumber2.ToString());
                            output.WriteLine("  //");
                            output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                            output.WriteLine(node.ToFullString());
                            output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 5 ------------");
                            output.WriteLine("  //");

                         //   throw new NotImplementedException();
                        }
                    }
                    else
                    {
                        throw new NotImplementedException();
                    }

				}
				//else if (isPatternExpressionSyntax.Expression.Kind() == SyntaxKind.SimpleMemberAccessExpression)
				//{
				//	GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
				//	output.WriteLine("ACABO9999");
    //            }
                else
                {
                    var kind2 = isPatternExpressionSyntax.Kind();
                    FileLinePositionSpan span2 = node.SyntaxTree.GetLineSpan(isPatternExpressionSyntax.Span);
                    int lineNumber2 = span2.StartLinePosition.Line + 1;

                    output.WriteLine();
                    output.WriteLine("  //");
                    output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind2.ToString());
                    output.WriteLine("  // Kind: " + node.Kind().ToString());
                    output.WriteLine("  // Type: " + node.GetType().Name);
                    output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                    output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                    output.WriteLine("  // Linha: " + lineNumber2.ToString());
                    output.WriteLine("  // Descoberta do erro em:  27/09/2023 - Marcelo Melo");
                    output.WriteLine("  //");
                    output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                    output.WriteLine(node.ToFullString());
                    output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 5-OLD ------------");
                    output.WriteLine("  //");

                  //  throw new NotImplementedException();
                }
            }
            else if (isPatternExpressionSyntax.Pattern.IsKind(SyntaxKind.DeclarationPattern))
			{

				if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.ThisExpression))
				{
					GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
					output.WriteLine("ACAB10101010101010");

				}
                else if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.IdentifierName))
                {
                    GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
                    output.Write(" is ");

                    DeclarationPatternSyntax declarationPatternSyntax = (DeclarationPatternSyntax)isPatternExpressionSyntax.Pattern;

                    output.Write(CSharpToObjectPascalType(declarationPatternSyntax.Type));
                    //output.Write(identifierNameSyntax.ToString());


                    if (declarationPatternSyntax.Designation.IsKind(SyntaxKind.SingleVariableDesignation))
                    {
                        SingleVariableDesignationSyntax singleVariableDesignationSyntax = (SingleVariableDesignationSyntax)declarationPatternSyntax.Designation;

                        output.Write(" { var ");
                        output.Write(singleVariableDesignationSyntax.ToString());
                        output.Write(": ");
                        output.Write(CSharpToObjectPascalType(declarationPatternSyntax.Type));
                        //output.Write(identifierNameSyntax.ToString());
                        output.Write(" := ");
                        GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
                        output.Write(" as ");
                        //output.Write(identifierNameSyntax.ToString());
                        output.Write(CSharpToObjectPascalType(declarationPatternSyntax.Type));
                        output.Write("; } ");
                    }
                    else
					{
						throw new NotImplementedException();
					}

                }
                else if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.SimpleMemberAccessExpression))
                {
                    GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
                    output.WriteLine("ACAB22222222222222222222222222222222222222222222");

                }
				else if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.InvocationExpression))
				{
					GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
					output.WriteLine("ACABOU444");

				}
				else if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.ConditionalAccessExpression))
				{
					GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
					output.WriteLine("ACABOU5555");

				}
                else if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.ElementAccessExpression))
                {
                    GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
                    output.WriteLine("ACABOU3333333333333333333333333333333333333333");

                }
                else
                {
                    output.WriteLine();
                    output.WriteLine("  //");
                    output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                    output.WriteLine("  // Kind: " + node.Kind().ToString());
                    output.WriteLine("  // Type: " + node.GetType().Name);
                    output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                    output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                    output.WriteLine("  // Linha: " + lineNumber.ToString());
                    output.WriteLine("  //");
                    output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                    output.WriteLine(node.ToFullString());
                    output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 04/03/2024-4 ------------");
                    output.WriteLine("  //");

                }
            }
            else if (isPatternExpressionSyntax.Pattern.IsKind(SyntaxKind.RecursivePattern))
			{
                if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.IdentifierName))
                {
                    GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
                    output.WriteLine("ACABOU344444444444444444444444444444444444444444");

                }
                else if (isPatternExpressionSyntax.Expression.IsKind(SyntaxKind.ConditionalAccessExpression))
                {
                    GenerateExpressionSyntax(isPatternExpressionSyntax.Expression);
                    output.WriteLine("ACABOU355555555555555555555555555555555555555");
                } 
            }
            else if (isPatternExpressionSyntax.Pattern.IsKind(SyntaxKind.OrPattern))
			{
                output.Write(isPatternExpressionSyntax.Pattern.ToString());
            }
            else
            {
                var kind2 = isPatternExpressionSyntax.Pattern.Kind();
                FileLinePositionSpan span2 = node.SyntaxTree.GetLineSpan(isPatternExpressionSyntax.Pattern.Span);
                int lineNumber2 = span2.StartLinePosition.Line + 1;

                output.WriteLine();
                output.WriteLine("  //");
                output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind2.ToString());
                output.WriteLine("  // Kind: " + node.Kind().ToString());
                output.WriteLine("  // Type: " + node.GetType().Name);
                output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                output.WriteLine("  // Linha: " + lineNumber2.ToString());
                output.WriteLine("  //");
                output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                output.WriteLine(node.ToFullString());
                output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 5-OLD2 ------------");
                output.WriteLine("  //");

               // throw new NotImplementedException();
            }
        }

        private void GenerateThrowExpressionSyntax(ThrowExpressionSyntax throwExpressionSyntax)
        {
            output.Write("raise ");
            GenerateExpressionSyntax(throwExpressionSyntax.Expression);
        }

        private void GenerateSimpleLambdaExpressionSyntax(SimpleLambdaExpressionSyntax node)
        {

			var currentIndent = output.Indent;
            
            output.WriteLine();
			output.Indent++;
            output.Indent++;
            output.Write("procedure(");

			GenerateParameterSyntax(node.Parameter);

            output.WriteLine(")");
            output.WriteLine("begin");
            output.Indent++;

            GenerateBlockSyntax(node.Block);
			GenerateExpressionSyntax(node.ExpressionBody);
            output.WriteLine(";");
            output.Indent--;
            output.WriteLine("end");
			output.Indent--;
            output.Indent--;


        }

        private void GenerateParameterSyntax(ParameterSyntax parameter)
        {
            if (parameter.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
                output.Write("const ");
            else if (parameter.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
                output.Write("var ");
            else if (parameter.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
                output.Write("out ");
			else if (parameter.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
				output.Write("const ");
			else
				output.Write("const ");

			output.Write(CodeGenUtils.CreateEscapedIdentifier(parameter.Identifier.Text));
            output.Write(": " + CSharpToObjectPascalType(parameter.Type));
        }

        private void GenerateParenthesizedLambdaExpressionSyntax(ParenthesizedLambdaExpressionSyntax e)
        {

			output.Write("function(");

			if (e.ParameterList != null)
			{
				SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = e.ParameterList.Parameters;
				foreach (ParameterSyntax param in parameterSyntaxCollection)
				{
					if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
						output.Write("const ");
					else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
						output.Write("var ");
					else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
						output.Write("out ");
					else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
						output.Write("const ");
					else
						output.Write("const ");

					output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.ValueText));

					if (param.Type is null)
                    {
						// anonymous method with parameter
						output.Write(": Variant");
					}
					else if (param.Type is not null) {
						output.Write(": " + CSharpToObjectPascalType(param.Type));
					}

					if (!param.Equals(parameterSyntaxCollection.Last()))
						output.Write("; ");
				}

			}

			output.WriteLine("): TRttiValue");
			output.WriteLine("begin");
			output.Indent++;
			output.Write("Result := ");
			GenerateExpressionSyntax(e.ExpressionBody);
			output.WriteLine(";");
			output.Indent--;
			output.Write("end");


		}

		private void GeneratePointerTypeSyntax(PointerTypeSyntax node)
        {
			output.Write(CSharpToObjectPascalType(node));

		}

        private void GenerateAnonymousMethodExpressionSyntax(AnonymousMethodExpressionSyntax e)
        {
			output.Write("procedure(");

			if (e.ParameterList != null)
            {
				SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = e.ParameterList.Parameters;
				foreach (ParameterSyntax param in parameterSyntaxCollection)
				{

					if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
						output.Write("const ");
					else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
						output.Write("var ");
					else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
						output.Write("out ");
					else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
						output.Write("const ");
					else
						output.Write("const ");

					output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.ValueText));
					output.Write(": " + CSharpToObjectPascalType(param.Type));

					if (!param.Equals(parameterSyntaxCollection.Last()))
						output.Write("; ");
				}

			}

			output.WriteLine(")");
			output.WriteLine("begin");
			GenerateBlockSyntax(e.Block);
			output.Write("end");
		}

		private void GenerateArrayTypeSyntax(ArrayTypeSyntax node)
        {
			output.Write("TArray<" + CSharpToObjectPascalType(node.ElementType) + ">");

		}

        private void GenerateSizeOfExpressionSyntax(SizeOfExpressionSyntax node)
        {
			output.Write("SizeOf(");
			output.Write(CSharpToObjectPascalType(node.Type));
			output.Write(")");
		}

		private void GeneratePrefixUnaryExpressionSyntax(PrefixUnaryExpressionSyntax node)
        {
			if (node.Kind() == SyntaxKind.PreIncrementExpression)
            {
				output.Write("Inc(");
				GenerateExpressionSyntax(node.Operand);
				output.Write(")");
			}
			else if(node.Kind() == SyntaxKind.PreDecrementExpression)
			{
				output.Write("Dec(");
				GenerateExpressionSyntax(node.Operand);
				output.Write(")");
			}
			else if (node.Kind() == SyntaxKind.UnaryPlusExpression)
			{
				if (node.Operand is InvocationExpressionSyntax || node.Operand is ParenthesizedExpressionSyntax || node.Operand is MemberAccessExpressionSyntax || node.Operand is IdentifierNameSyntax)
					output.Write("+");

				GenerateExpressionSyntax(node.Operand);
			}
			else if (node.Kind() == SyntaxKind.UnaryMinusExpression)
			{
				if (node.Operand is InvocationExpressionSyntax || node.Operand is ParenthesizedExpressionSyntax || node.Operand is MemberAccessExpressionSyntax || node.Operand is IdentifierNameSyntax)
					output.Write("-");

				GenerateExpressionSyntax(node.Operand);
			}
            else if (node.Kind() == SyntaxKind.PointerIndirectionExpression)
            {
                GenerateExpressionSyntax(node.Operand);
				output.Write("^");
            }
            else if (node.Kind() == SyntaxKind.AddressOfExpression)
            {
                output.Write("@");
                GenerateExpressionSyntax(node.Operand);
            }
            else
            {
				var kind = node.Kind();
				FileLinePositionSpan span = node.SyntaxTree.GetLineSpan(node.Span);
				int lineNumber = span.StartLinePosition.Line + 1;

				output.WriteLine();
				output.WriteLine("  //");
				output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                output.WriteLine("  // Kind: " + node.Kind().ToString());
                output.WriteLine("  // Type: " + node.GetType().Name);
                output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
				output.WriteLine("  // Posição: " + node.FullSpan.ToString());
				output.WriteLine("  // Linha: " + lineNumber.ToString());
				output.WriteLine("  //");
				output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
				output.WriteLine(node.ToFullString());
				output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 5-OLD3 ------------");
				output.WriteLine("  //");

			}
		}

        private void GenerateArrayCreationExpressionSyntax(ArrayCreationExpressionSyntax node)
        {

			if (node.Initializer != null)
            {
				GenerateArrayInitializerExpressionSyntax(node.Initializer);
			}
			else
            {
				output.Write(CSharpToObjectPascalType(node.Type));
				output.Write(".Create(");

				output.WriteLine(");");
				output.Write("SetLength(");

				if (node.Parent.Parent is VariableDeclaratorSyntax variableDeclarator) 
				{
					output.Write(CodeGenUtils.CreateEscapedIdentifier(variableDeclarator.Identifier.ValueText));
                }


				foreach (ArrayRankSpecifierSyntax arrayRankSpecifier in node.Type.RankSpecifiers)
				{
					foreach(ExpressionSyntax expression in arrayRankSpecifier.Sizes)
                    {
						output.Write(", ");
						GenerateExpressionSyntax(expression);
					}

				}

				output.Write(")");

                // verificar isso
                //Debug.Assert(false, "verificar isso aqui");
            }

        }

		private void GenerateDefaultExpressionSyntax(DefaultExpressionSyntax node)
        {
			output.Write("Default(");
			output.Write(CSharpToObjectPascalType(node.Type));
			output.Write(")");
		}

		private void GenerateCoalesceExpressionSyntax(BinaryExpressionSyntax e)
        {
			output.Write("IfThen(");
			GenerateExpressionSyntax(e.Left);
			output.Write(" = nil, ");
			GenerateExpressionSyntax(e.Right);
			output.Write(", ");
			GenerateExpressionSyntax(e.Left);
			output.Write(")");
        }


        private void GenerateMemberBindingExpressionSyntax(MemberBindingExpressionSyntax node)
        {
			output.Write(".");
			output.Write(node.Name.Identifier.ValueText);
        }

        private void GenerateQualifiedNameSyntax(QualifiedNameSyntax node)
        {
			output.Write(node.ToFullString());
		}

		private void GenerateThisExpressionSyntax(ThisExpressionSyntax node)
        {
			output.Write("Self");
        }

        private void GenerateConditionalAccessExpressionSyntax(ConditionalAccessExpressionSyntax e)
        {

			//output.WriteLine();
			output.Write(@"if Assigned(");
			GenerateExpressionSyntax(e.Expression);
			output.WriteLine(@") then");
			output.Indent++;
			GenerateExpressionSyntax(e.Expression);
			GenerateExpressionSyntax(e.WhenNotNull);
			output.Write(";");
			output.Indent--;
			//output.WriteLine();

		}

		private void GeneratePostfixUnaryExpressionSyntax(PostfixUnaryExpressionSyntax node)
		{
			GenerateExpressionSyntax(node.Operand);
			output.Write(" := ");
			GenerateExpressionSyntax(node.Operand);

			if (node.Kind() == SyntaxKind.PostIncrementExpression)
				output.Write(" + 1");
			else if (node.Kind() == SyntaxKind.PostDecrementExpression)
				output.Write(" - 1");
			else 
			{
				Console.WriteLine("strict private void GeneratePostfixUnaryExpressionSyntax(PostfixUnaryExpressionSyntax node) operando não implementado");
				throw new NotImplementedException(node.Kind().ToString() + "\n\nprivate void GeneratePostfixUnaryExpressionSyntax(PostfixUnaryExpressionSyntax node) operando não implementado");
			}

			output.WriteLine(";");
		}


		private void GenerateCoalesceAssignmentExpressionSyntax(AssignmentExpressionSyntax node)
		{
			//GenerateExpressionSyntax(node.Left);
			//output.WriteLine(";");
			output.WriteLine();

			output.Write("if (");
			GenerateExpressionSyntax(node.Left);
			output.WriteLine(" = nil) then");
			//output.WriteLine("begin");
			output.Indent++;

			if (node.Right is ThrowExpressionSyntax throwExpressionSyntax)
            {
                GenerateThrowExpressionSyntax(throwExpressionSyntax);
            }
            else
            {
                GenerateExpressionSyntax(node.Left);
                output.Write(" := ");
                GenerateExpressionSyntax(node.Right);
                if (node.Parent?.Parent?.Kind() == SyntaxKind.PropertyDeclaration)
                {
                    output.WriteLine();
                    output.Write("Result := ");
                    GenerateExpressionSyntax(node.Left);
                }
            }

            output.WriteLine(";");
            output.Indent--;
            //output.WriteLine("end;");

        }

        private void GenerateAssignmentExpressionSyntax(AssignmentExpressionSyntax node)
        {

			GenerateTriviaListSyntax(node.GetLeadingTrivia());
			

			if ((node.Right.Kind() == SyntaxKind.ConditionalExpression) && (node.Right is ConditionalExpressionSyntax))
			{
				ConditionalExpressionSyntax conditionalExpressionSyntax = node.Right as ConditionalExpressionSyntax;


                output.WriteLine();
                output.Write("if (");
				GenerateExpressionSyntax(conditionalExpressionSyntax.Condition);
				output.WriteLine(") then");
				//output.WriteLine("begin");

				output.Indent++;
				output.Write(node.Left.ToString());
				output.Write(" := ");
				GenerateExpressionSyntax(conditionalExpressionSyntax.WhenTrue);
				//output.WriteLine(";");
                output.WriteLine();
                output.Indent--;
				//output.WriteLine("end");

				output.WriteLine("else");
				//output.WriteLine("begin");
				output.Indent++;
				output.Write(node.Left.ToString());
				output.Write(" := ");
				GenerateExpressionSyntax(conditionalExpressionSyntax.WhenFalse);
				output.WriteLine(";");                
                output.Indent--;
				//output.WriteLine("end;");
			}
			else if ((node.Right.Kind() == SyntaxKind.CoalesceExpression)) //&& (node.Right is BinaryExpressionSyntax))
			{
				BinaryExpressionSyntax binaryExpressionSyntax = node.Right as BinaryExpressionSyntax;

				output.Write(node.Left.ToString());
				output.Write(" := ");
				GenerateExpressionSyntax(binaryExpressionSyntax.Left);
				output.WriteLine(";");

				output.Write("if (");
				output.Write(node.Left.ToString());
				output.Write(" = nil");
				output.WriteLine(") then");

                output.Indent++;
                if (binaryExpressionSyntax.Right.IsKind(SyntaxKind.ThrowExpression))
				{
					GenerateThrowExpressionSyntax(binaryExpressionSyntax.Right as ThrowExpressionSyntax);
				}
				else
				{
					output.Write(node.Left.ToString());
					output.Write(" := ");
					GenerateExpressionSyntax(binaryExpressionSyntax.Right);
				}
				
				output.WriteLine(";");
				output.Indent--;
				output.WriteLine();
			}
			else
			{
				if (node.Right is ArrayCreationExpressionSyntax)
                {
					output.Write("SetLength(");
					GenerateExpressionSyntax(node.Left);
					output.Write(", ");

					ArrayCreationExpressionSyntax arrayCreationExpressionSyntax = (ArrayCreationExpressionSyntax)node.Right;
					ArrayTypeSyntax arrayTypeSyntax = arrayCreationExpressionSyntax.Type;

					foreach(ArrayRankSpecifierSyntax arrayRankSpecifier in arrayTypeSyntax.RankSpecifiers) 
					{

						output.Write(arrayRankSpecifier.Sizes.ToString());

						if (!arrayRankSpecifier.Equals(arrayTypeSyntax.RankSpecifiers.Last()))
						{
							output.Write(", ");
						}
					}


					output.Write(")");

				}
				else
                {
					GenerateExpressionSyntax(node.Left);
					output.Write(" := ");

					switch (node.Kind()) 
					{
						case SyntaxKind.AddAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" + ");
							break;

						case SyntaxKind.SubtractAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" - ");
							break;

						case SyntaxKind.AndAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" and ");
							break;

						case SyntaxKind.OrAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" or ");
							break;

						case SyntaxKind.DivideAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" / ");
							break;

						case SyntaxKind.MultiplyAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" * ");
							break;

						case SyntaxKind.ModuloAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" mod ");
							break;

						case SyntaxKind.ExclusiveOrAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" xor ");
							break;

						case SyntaxKind.LeftShiftAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" shl ");
							break;

						case SyntaxKind.RightShiftAssignmentExpression:
							GenerateExpressionSyntax(node.Left);
							output.Write(" shr ");
							break;

					}



					GenerateExpressionSyntax(node.Right);
				}

				output.Write(";");
			}


		}
		
        private void GenerateArrayInitializerExpressionSyntax(InitializerExpressionSyntax initializer)
        {
			if (initializer == null)
				return;

			output.Write("[");

			foreach (ExpressionSyntax expressionSyntax in initializer.Expressions)
            {
				GenerateExpressionSyntax(expressionSyntax);

				if (!expressionSyntax.Equals(initializer.Expressions.Last()))
                {
					output.Write(", ");
                }
            }

			output.Write("]");

		}


        private void GenerateElementAccessExpressionSyntax(ElementAccessExpressionSyntax node)
        {
			output.Write(node.ToString());
		}

		private void GenerateConditionalExpressionSyntax(ConditionalExpressionSyntax node)
        {

			output.Write("IfThen(");
			GenerateExpressionSyntax(node.Condition);
			output.Write(", ");
			GenerateExpressionSyntax(node.WhenTrue);
			output.Write(", ");
			GenerateExpressionSyntax(node.WhenFalse);
			output.Write(")");

		}

		private void GeneratePredefinedTypeSyntax(PredefinedTypeSyntax node)
        {
			output.Write(node.ToFullString());
		}

		private void GenerateCastExpressionSyntax(CastExpressionSyntax node)
        {

			if (node.Type.IsKind(SyntaxKind.PredefinedType))
				output.Write(CSharpToObjectPascalType(node.Type));
			else if (node.Type.IsKind(SyntaxKind.IdentifierName))
				output.Write(CSharpToObjectPascalType(node.Type));
			else
				GenerateExpressionSyntax(node.Type);

			output.Write("(");
			GenerateExpressionSyntax(node.Expression);
			output.Write(")");


		}

		private void GenerateTypeOfExpressionSyntax(TypeOfExpressionSyntax node)
        {
			output.Write("TypeInfo(");
            output.Write(CSharpToObjectPascalType(node.Type));
			output.Write(")");
		}

		private void GenerateParenthesizedExpressionSyntax(ParenthesizedExpressionSyntax node)
		{
			
			output.Write("(");
			GenerateExpressionSyntax(node.Expression);
			output.Write(")");
		}

		private void GenerateObjectCreationExpressionSyntax(ObjectCreationExpressionSyntax node)
		{
			output.Write(CSharpToObjectPascalType(node.Type));

			output.Write(".Create(");

			GenerateArgumentListSyntax(node.ArgumentList);

			output.Write(")");

			//if (node.Initializer != null)
			//{
			//	GenerateExpressionSyntax(node.Initializer);
			//}

		}

		private void GenerateImplicitObjectCreationExpressionSyntax(ImplicitObjectCreationExpressionSyntax node, TypeSyntax type)
		{
			output.Write(CSharpToObjectPascalType(type));

			output.Write(".Create(");

			GenerateArgumentListSyntax(node.ArgumentList);

			output.Write(")");

			//if (node.Initializer != null)
			//{
			//	GenerateExpressionSyntax(node.Initializer);
			//}

		}



		private void GenerateBinaryExpressionSyntax(BinaryExpressionSyntax node)
		{

			GenerateExpressionSyntax(node.Left);

			switch (node.Kind())
			{
				case SyntaxKind.EqualsExpression:
					output.Write(" = ");
					break;

				case SyntaxKind.NotEqualsExpression:
					output.Write(" <> ");
					break;

				case SyntaxKind.GreaterThanExpression:
					output.Write(" > ");
					break;

				case SyntaxKind.GreaterThanOrEqualExpression:
					output.Write(" >= ");
					break;



				case SyntaxKind.LessThanExpression:
					output.Write(" < ");
					break;

				case SyntaxKind.LessThanOrEqualExpression:
					output.Write(" <= ");
					break;

				case SyntaxKind.LogicalOrExpression:
					output.Write(") or (");
					break;

				case SyntaxKind.LogicalAndExpression:
					output.Write(") and (");
					break;

				case SyntaxKind.ExclusiveOrExpression:
					output.Write(" xor ");
					break;

				case SyntaxKind.AddExpression:
					output.Write(" + ");
					break;

				case SyntaxKind.DivideExpression:
					output.Write(" / ");
					break;

				case SyntaxKind.MultiplyExpression:
					output.Write(" * ");
					break;

				case SyntaxKind.SubtractExpression:
					output.Write(" - ");
					break;

				case SyntaxKind.LeftShiftExpression:
					output.Write(" shl ");
					break;

				case SyntaxKind.RightShiftExpression:
					output.Write(" shr ");
					break;

				case SyntaxKind.BitwiseOrExpression:
					output.Write(" or ");
					break;

				case SyntaxKind.BitwiseAndExpression:
					output.Write(" and ");
					break;

				case SyntaxKind.IsExpression:
					output.Write(" is ");
					break;

				case SyntaxKind.AsExpression:
					output.Write(" as ");
					break;

				case SyntaxKind.ModuloExpression:
					output.Write(" mod ");
					break;

				default:
					throw new NotSupportedException("E006 - Não implementado: " + node.Kind().ToString());
			}

			GenerateExpressionSyntax(node.Right);
		}



		private void GenerateInvocationExpressionSyntax(InvocationExpressionSyntax node)
        {
			if (node.ArgumentList != null)
			{

				foreach (ArgumentSyntax argument in node.ArgumentList.Arguments)
				{
					if (argument.Expression.IsKind(SyntaxKind.DeclarationExpression))
					{
                        DeclarationExpressionSyntax declarationExpressionSyntax = (DeclarationExpressionSyntax)argument.Expression;

                        VariableDesignationSyntax variableDesignationSyntax = declarationExpressionSyntax.Designation;
                        if (variableDesignationSyntax.IsKind(SyntaxKind.SingleVariableDesignation))
						{
							SingleVariableDesignationSyntax singleVariableDesignationSyntax = (SingleVariableDesignationSyntax)variableDesignationSyntax;

                            output.Write("var ");
                            var variableName = CodeGenUtils.CreateEscapedIdentifier(singleVariableDesignationSyntax.Identifier.ValueText);
                            output.Write(variableName);
                            output.Write(": " + CSharpToObjectPascalType(declarationExpressionSyntax.Type));

                            output.WriteLine(";");

                        }

                    }
				}

            }


            GenerateExpressionSyntax(node.Expression);
			output.Write("(");

			GenerateArgumentListSyntax(node.ArgumentList);

			output.Write(")");
		}

        private void GenerateArgumentListSyntax(ArgumentListSyntax node)
        {
			if (node != null)
			{

				foreach (ArgumentSyntax argument in node.Arguments)
				{
					GenerateArgumentSyntax(argument);

					if (!argument.Equals(node.Arguments.Last()))
						output.Write(", ");
				}
			}
		}

        private void GenerateArgumentSyntax(ArgumentSyntax node)
        {

            // Console.WriteLine(node.Kind().ToString());
            // Console.WriteLine(node.Expression.Kind().ToString());
            // Console.WriteLine(node.Expression.ToString());

            if (node.Expression.IsKind(SyntaxKind.ThisExpression))
			{
				output.Write("Self");
			}
			else if (node.Expression.IsKind(SyntaxKind.NumericLiteralExpression))
			{
				GenerateNumericLiteralExpressionSyntax(node.Expression);
				//output.Write(node.Expression.ToString());
			}
			else if (node.Expression.IsKind(SyntaxKind.EqualsExpression))
			{
				output.Write(" = ");
			}
			else if (node.Expression.IsKind(SyntaxKind.IdentifierName))
			{
				output.Write(node.Expression.ToString());
			}
			else if (node.Expression.IsKind(SyntaxKind.SimpleMemberAccessExpression))
			{
				output.Write(node.Expression.ToString());
			}
			else if (node.Expression.IsKind(SyntaxKind.Argument))
			{
				output.Write(node.ToString());
			}
			else if (node.Expression.IsKind(SyntaxKind.ObjectCreationExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.TypeOfExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.NullLiteralExpression))
			{
				output.Write(" nil ");
			}
			else if (node.Expression.IsKind(SyntaxKind.FalseLiteralExpression))
			{
				output.Write(" False ");
			}
			else if (node.Expression.IsKind(SyntaxKind.LogicalNotExpression))
			{
				output.Write(" not ");
			}
			else if (node.Expression.IsKind(SyntaxKind.NotEqualsExpression))
			{
				output.Write(" <> ");
			}
			else if (node.Expression.IsKind(SyntaxKind.TrueLiteralExpression))
			{
				output.Write(" True ");
			}
			else if (node.Expression.IsKind(SyntaxKind.InvocationExpression))
			{
				GenerateInvocationExpressionSyntax((InvocationExpressionSyntax)node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.ElementAccessExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.AddExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.CastExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.GreaterThanExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.GreaterThanOrEqualExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.LogicalAndExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.LessThanOrEqualExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.LogicalOrExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			else if (node.Expression.IsKind(SyntaxKind.ArrayCreationExpression))
			{
				GenerateExpressionSyntax(node.Expression);
			}
			//else if (node.Expression.IsKind(SyntaxKind.UnaryMinusExpression))
			//{
			//	GenerateExpressionSyntax(node.Expression);
			//}
			else
			{
				GenerateExpressionSyntax(node.Expression);
			}

		}

		private void GenerateMethodBodySyntax(BlockSyntax blockSyntax)
        {
			if (blockSyntax == null)
				return;

			output.Indent++;

			GenerateStatementsSyntax(blockSyntax.Statements);

			output.Indent--;
			//output.WriteLine("");

		}

        private void GenerateStatementsSyntax(SyntaxList<StatementSyntax> statements)
        {
			foreach (StatementSyntax statement in statements)
			{
				GenerateStatementSyntax(statement);
			}
		}

		private void GenerateBlockSyntax(BlockSyntax node)
		{
            if (node == null)
            {
				return;
			}

			output.Write("begin");
            GenerateTriviaListSyntax(node.OpenBraceToken.TrailingTrivia, true);

            output.Indent++;

            foreach (StatementSyntax statement in node.Statements)
			{
                GenerateStatementSyntax(statement);
            }

            output.Indent--;

            GenerateTriviaListSyntax(node.CloseBraceToken.LeadingTrivia, false);
            output.Write("end;");
            GenerateTriviaListSyntax(node.CloseBraceToken.TrailingTrivia, true);
        }

        private void GenerateStatementSyntax(StatementSyntax e)
        {
          //  GenerateLeadingTriviaSyntax(e);
            if (e is ReturnStatementSyntax)
			{
				GenerateReturnStatementSyntax((ReturnStatementSyntax)e);
			}
			else if (e is ContinueStatementSyntax)
			{
				GenerateContinueStatementSyntax((ContinueStatementSyntax)e);
			}
			else if (e is BreakStatementSyntax)
			{
				GenerateBreakStatementSyntax((BreakStatementSyntax)e);
			}
			else if (e is BlockSyntax)
			{
				GenerateBlockSyntax((BlockSyntax)e);
			}
			else if (e is IfStatementSyntax)
			{
				GenerateIfStatementSyntax((IfStatementSyntax)e);
			}
			else if (e is ForEachStatementSyntax)
			{
				GenerateForEachStatementSyntax((ForEachStatementSyntax)e);
			}
			else if (e is TryStatementSyntax)
			{
				GenerateTryStatementSyntax((TryStatementSyntax)e);
			}
			else if (e is DoStatementSyntax)
			{
				GenerateDoStatementSyntax((DoStatementSyntax)e);
			}
			else if (e is ThrowStatementSyntax)
			{
				GenerateThrowStatementSyntax((ThrowStatementSyntax)e);
			}
			else if (e is ExpressionStatementSyntax)
			{
				GenerateExpressionStatementSyntax((ExpressionStatementSyntax)e);
			}
			else if (e is ForStatementSyntax)
			{
				GenerateForStatementSyntax((ForStatementSyntax)e);
			}
			else if (e is GotoStatementSyntax)
			{
				GenerateGotoStatementSyntax((GotoStatementSyntax)e);
			}
			else if (e is LabeledStatementSyntax)
			{
				GenerateLabeledStatementSyntax((LabeledStatementSyntax)e);
			}
			else if (e is LocalDeclarationStatementSyntax)
			{
				GenerateLocalDeclarationStatementSyntax((LocalDeclarationStatementSyntax)e);
			}
			//else if (e is LocalFunctionStatementSyntax)
			//{
			//	Console.WriteLine("LocalFunctionStatementSyntax ainda não implementado");
			//	throw new NotImplementedException("LocalFunctionStatementSyntax ainda não implementado");
			//}
			else if (e is LockStatementSyntax)
			{
				GenerateLockStatementSyntax((LockStatementSyntax)e);
			}
			else if (e is SwitchStatementSyntax)
			{
				GenerateSwitchStatementSyntax((SwitchStatementSyntax)e);
			}
			else if (e is WhileStatementSyntax)
			{
				GenerateWhileStatementSyntax((WhileStatementSyntax)e);
			}
			else if (e is UsingStatementSyntax)
			{
				GenerateUsingStatementSyntax((UsingStatementSyntax)e);
			}
			else if (e is EmptyStatementSyntax)
			{
				output.WriteLine();
			}
			else if (e is LocalFunctionStatementSyntax)
            {
				// Ja emitido na hora da declaração da implementação do metodo
            }
            else if (e is FixedStatementSyntax)
            {
                GenerateFixedStatementSyntax((FixedStatementSyntax)e);
            }
            else
            {
				FileLinePositionSpan span = e.SyntaxTree.GetLineSpan(e.Span);
				int lineNumber = span.StartLinePosition.Line + 1;

				output.WriteLine("  //");
				output.WriteLine("  // Comando não implementado pelo ObjectPascalCodeGenerator: " + e.Kind().ToString());
                output.WriteLine("  // Kind: " + e.Kind().ToString());
                output.WriteLine("  // Type: " + e.GetType().Name);
                output.WriteLine("  // Arquivo: " + e.SyntaxTree.FilePath);
				output.WriteLine("  // Posição: " + e.FullSpan.ToString());
				output.WriteLine("  // Linha: " + lineNumber.ToString());
				output.WriteLine("  //");
				output.WriteLine("  // ----------- começa aqui o comando não suportado ------------");
				output.WriteLine(e.ToFullString());
				output.WriteLine("  // ----------- TERMINA AQUI O COMANDO SEM SUPORTE - 4 ------------");
				output.WriteLine("  //");
			}
        }

        private void GenerateFixedStatementSyntax(FixedStatementSyntax e)
        {
            foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in e.Declaration.Variables)
            {
                GenerateVariableDeclaratorSyntax(variableDeclaratorSyntax);
            }

            GenerateStatementSyntax(e.Statement);
        }

        private void GenerateUsingStatementSyntax(UsingStatementSyntax e)
        {
			if (e.Expression != null)
			{
				var varStmtUsingExpForFree = "StmtUsingExpForFree";
				output.Write("var ");
				output.Write(varStmtUsingExpForFree);
				output.Write(" := ");
				GenerateExpressionSyntax(e.Expression);
				output.WriteLine(";");
				output.WriteLine("try");
				output.Indent++;

				GenerateStatementSyntax(e.Statement);

				output.Indent--;
				output.WriteLine("finally");
				output.Indent++;

				output.Write("if not IsManagedType(");
				output.Write(varStmtUsingExpForFree);
				output.Write(") and Assigned(");
				output.Write(varStmtUsingExpForFree);
				output.Write(") then FreeAndNil(");
				output.Write(varStmtUsingExpForFree);
				output.WriteLine(");");


				output.Indent--;
				output.WriteLine("end;");

			}
			else
			{
				foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in e.Declaration.Variables)
				{
					GenerateVariableDeclaratorSyntax(variableDeclaratorSyntax);
				}

				output.WriteLine("try");
				output.Indent++;

				GenerateStatementSyntax(e.Statement);

				output.Indent--;
				output.WriteLine("finally");
				output.Indent++;

				foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in e.Declaration.Variables)
				{
					GenerateVariableDestructorSyntax(variableDeclaratorSyntax);
				}


				output.Indent--;
				output.WriteLine("end;");
			}
		}

        private void GenerateVariableDestructorSyntax(VariableDeclaratorSyntax e)
        {
			if (e.Parent is VariableDeclarationSyntax)
			{
				VariableDeclarationSyntax variableDeclarationSyntax = e.Parent as VariableDeclarationSyntax;


				if (!variableDeclarationSyntax.Type.IsVar)
				{
					output.Write("if Assigned(");
					output.Write(CodeGenUtils.CreateEscapedIdentifier(e.Identifier.ValueText));
					output.WriteLine(") then");
					output.Indent++;
					output.Write("FreeAndNil(");
					output.Write(CodeGenUtils.CreateEscapedIdentifier(e.Identifier.ValueText));
					output.WriteLine(");");
					output.Indent--;
				}



			}

		}

		private void GenerateLabeledStatementSyntax(LabeledStatementSyntax e)
        {
			output.Indent--;
			output.WriteLine(e.Identifier.ToString() + ":");
			output.Indent++;
			GenerateStatementSyntax(e.Statement);
			output.Indent--;
		}

		private void GenerateGotoStatementSyntax(GotoStatementSyntax e)
        {
			output.Write("goto ");
			GenerateExpressionSyntax(e.Expression);
			output.WriteLine(";");
		}

		private void GenerateWhileStatementSyntax(WhileStatementSyntax e)
        {
			output.WriteLine();

			output.Write("while (");
			GenerateExpressionSyntax(e.Condition);
			output.Write(")");
			output.WriteLine(" do");
			output.WriteLine("begin");
			output.Indent++;

			GenerateStatementSyntax(e.Statement);
			output.WriteLine();

			output.Indent--;
			output.WriteLine("end;");
		}

		private void GenerateDoStatementSyntax(DoStatementSyntax e)
        {
			output.WriteLine();
		
			output.WriteLine("repeat");
			output.Indent++;

			GenerateStatementSyntax(e.Statement);
			output.WriteLine();

			output.Indent--;
			output.Write("until not (");
			GenerateExpressionSyntax(e.Condition);
			output.WriteLine(");");

		}

		private void GenerateForStatementSyntax(ForStatementSyntax e)
        {
			output.WriteLine();

			if (e.Declaration != null)
            {
				foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in e.Declaration.Variables)
				{
					GenerateVariableDeclaratorSyntax(variableDeclaratorSyntax);
				}
			}

			output.WriteLine();
			output.Write("while (");

			if (e.Condition == null)
				output.Write("True");
			else
				GenerateExpressionSyntax(e.Condition);

			output.WriteLine(") do");
			output.WriteLine("begin");
			output.Indent++;

			GenerateStatementSyntax(e.Statement);
			output.WriteLine();

			foreach(ExpressionSyntax incrementor in e.Incrementors)
            {
				GenerateExpressionSyntax(incrementor);
			}

			output.Indent--;
			output.WriteLine("end;");

        }

        private void GenerateLockStatementSyntax(LockStatementSyntax e)
        {
			output.Indent++;
			output.WriteLine();

			output.Write("TMonitor.Enter(");
			GenerateExpressionSyntax(e.Expression);
			output.WriteLine(");");

			output.WriteLine("try");
			output.Indent++;
				GenerateStatementSyntax(e.Statement);
				output.Indent--;
			output.WriteLine("finally");
			output.Indent++;
				output.Write("TMonitor.Leave(");
				GenerateExpressionSyntax(e.Expression);
				output.WriteLine(");");
				output.Indent--;
			output.WriteLine("end;");


			output.WriteLine();
			output.Indent--;
		}

		private void GenerateTryStatementSyntax(TryStatementSyntax e)
        {
			output.WriteLine("");

			var isFinally = (e.Finally != null);
			var isCatch = (e.Catches.Count() > 0);
			var isFinallyAndCath = isFinally && isCatch;

			if (isFinallyAndCath)
            {
				output.WriteLine("try");
				output.Indent++;
            }

			output.WriteLine("try");

			output.Indent++;
			GenerateBlockSyntax(e.Block);
			output.Indent--;

			if (isCatch)
            {
				foreach(CatchClauseSyntax catchClause in e.Catches)
                {
					GenerateCatchDeclarationSyntax(catchClause.Declaration);
					output.Indent++;

					var addBeginEnd = catchClause.Block.Statements.Count() > 1;

					if (addBeginEnd)
						output.WriteLine("begin");

					GenerateBlockSyntax(catchClause.Block);

					if (addBeginEnd)
						output.WriteLine("end;");

					output.Indent--;
				}
				output.WriteLine("end;");
			}

			if (isFinallyAndCath)
			{
				output.Indent--;
			}

			if (isFinally) 
			{ 
				output.WriteLine("finally");
				output.Indent++;
				GenerateBlockSyntax(e.Finally.Block);
				output.Indent--;
				output.WriteLine("end;");
			}

			output.WriteLine();

		}

		private void GenerateCatchDeclarationSyntax(CatchDeclarationSyntax e)
        {

			if (e == null)
				output.Write(" except on E: Exception");
			else
            {
				output.Write("except on ");
				output.Write(e.ToString());
			}
			output.WriteLine(" do");

		}

		private void GenerateThrowStatementSyntax(ThrowStatementSyntax e)
        {
            GenerateTriviaListSyntax(e.GetLeadingTrivia());
			output.Write("raise ");
			
			GenerateExpressionSyntax(e.Expression);

			output.Write(";");

            GenerateTriviaListSyntax(e.SemicolonToken.TrailingTrivia);
        }

        private void GenerateBreakStatementSyntax(BreakStatementSyntax e)
        {
			output.WriteLine("Break;");

		}

		private void GenerateContinueStatementSyntax(ContinueStatementSyntax e)
        {
			output.WriteLine("Continue;");
        }

        private void GenerateForEachStatementSyntax(ForEachStatementSyntax e)
        {
			output.WriteLine("");
			output.Write("for ");

			if (e.Type.IsVar)
			{
				output.Write("var ");
				output.Write(CodeGenUtils.CreateEscapedIdentifier(e.Identifier.ValueText));
				output.Write(" ");
			}
			else
			{
				output.Write("var ");
				output.Write(CodeGenUtils.CreateEscapedIdentifier(e.Identifier.ValueText));
				output.Write(": ");
				output.Write(e.Type.ToString());
				output.Write(" ");
			}


			output.Write("in ");
			GenerateExpressionSyntax(e.Expression);
			output.WriteLine(" do");
			output.WriteLine("begin");
			output.Indent++;
			GenerateStatementSyntax(e.Statement);
			output.Indent--;
			output.WriteLine("end;");
			output.WriteLine("");
		}

		private void GenerateLocalDeclarationStatementSyntax(LocalDeclarationStatementSyntax e)
        {
			foreach (VariableDeclaratorSyntax variableDeclaratorSyntax in e.Declaration.Variables)
            {
				GenerateVariableDeclaratorSyntax(variableDeclaratorSyntax);
            }
        }

        private void GenerateSwitchStatementSyntax(SwitchStatementSyntax e)
        {
			output.Write("case (");
			GenerateExpressionSyntax(e.Expression);
			output.Write(") of");

			GenerateTriviaListSyntax(e.OpenBraceToken.TrailingTrivia, true);

			output.Indent++;

			foreach(SwitchSectionSyntax switchSection in e.Sections)
            {
				foreach(SwitchLabelSyntax switchLabel in switchSection.Labels)
                {
					CaseSwitchLabelSyntax caseSwitchLabelSyntax = switchLabel as CaseSwitchLabelSyntax;

					if (caseSwitchLabelSyntax != null)
					{
                        GenerateTriviaListSyntax(caseSwitchLabelSyntax.GetLeadingTrivia(), false);
                        GenerateExpressionSyntax(caseSwitchLabelSyntax.Value);

						if (switchLabel == switchSection.Labels.Last())
							output.Write(":");
						else
                            output.Write(",");

                        GenerateTriviaListSyntax(switchLabel.GetTrailingTrivia(), true);
                  //      GenerateTriviaListSyntax(switchLabel.GetLeadingTrivia(), false);
                    }
                    else if (switchLabel.IsKind(SyntaxKind.DefaultSwitchLabel))
                    {
                        output.Indent--;
                        output.Write("else");

                        GenerateTriviaListSyntax(switchLabel.GetTrailingTrivia(), true);
//                        GenerateTriviaListSyntax(switchLabel.GetLeadingTrivia(), false);

                        output.Indent++;
                    }
                }

                if (switchSection.Statements.First().Kind() != SyntaxKind.Block)
                {
                    output.Write("begin");
                    GenerateTriviaListSyntax(switchSection.GetTrailingTrivia(), false);
                    output.Indent++;
                }


                foreach (StatementSyntax statement in switchSection.Statements)
                {
                    if (statement.Kind() != SyntaxKind.BreakStatement)
                        GenerateStatementSyntax(statement);
                }


                if (switchSection.Statements.First().Kind() != SyntaxKind.Block)
                {
                    output.Indent--;
                    output.Write("end;");
                    GenerateTriviaListSyntax(switchSection.GetLeadingTrivia(), false);
                    GenerateTriviaListSyntax(switchSection.GetTrailingTrivia(), false);
                }
            }


            output.Indent--;
			output.Write("end;");


            GenerateTriviaListSyntax(e.CloseBraceToken.TrailingTrivia, true);
        }

        private void GenerateExpressionStatementSyntax(ExpressionStatementSyntax e)
        {
			GenerateExpressionSyntax(e.Expression);
			if (e.Expression is InvocationExpressionSyntax)
            {
				output.Write(";");
			}

            GenerateTriviaListSyntax(e.SemicolonToken.LeadingTrivia, true);
            GenerateTriviaListSyntax(e.SemicolonToken.TrailingTrivia, true);

        }

        private void GenerateReturnStatementSyntax(ReturnStatementSyntax e)
        {
			output.WriteLine("");
			output.Write("Exit(");

			if (e.Expression != null)
			{
				GenerateExpressionSyntax(e.Expression);
			}

			output.WriteLine(");");
		}

		private void GenerateIfStatementSyntax(IfStatementSyntax e)
		{
			GenerateTriviaListSyntax(e.GetLeadingTrivia(), false);

			output.Write("if (");
			GenerateExpressionSyntax(e.Condition);
			output.Write(") then");

			GenerateTriviaListSyntax(e.CloseParenToken.TrailingTrivia, true);

            BlockSyntax blockIf = null;
            if (!e.Statement.IsKind(SyntaxKind.Block))
			{
				output.Indent++;
				GenerateStatementSyntax(e.Statement);
				output.Indent--;
			}
			else
			{
                blockIf = e.Statement as BlockSyntax;
				output.Write("begin");
				GenerateTriviaListSyntax(blockIf.OpenBraceToken.TrailingTrivia, true);

				output.Indent++;

				foreach (StatementSyntax statement in blockIf.Statements)
				{
					GenerateStatementSyntax(statement);
				}

				output.Indent--;
			}

			if (e.Else != null)
			{
                GenerateTriviaListSyntax(e.Else.ElseKeyword.LeadingTrivia, false);

                if (blockIf != null)
				{
                    GenerateTriviaListSyntax(blockIf.CloseBraceToken.LeadingTrivia, false);
                    output.Write("end");
                    GenerateTriviaListSyntax(blockIf.CloseBraceToken.TrailingTrivia, false);
                }

                output.Write("else");

				if (e.Else.Statement.IsKind(SyntaxKind.IfStatement))
				{
					output.Write(" ");
					GenerateIfStatementSyntax((IfStatementSyntax)e.Else.Statement);
				}
				else
				{
                    GenerateTriviaListSyntax(e.Else.ElseKeyword.TrailingTrivia, true);

                    if (!e.Else.Statement.IsKind(SyntaxKind.Block))
					{
						output.Indent++;
						GenerateStatementSyntax(e.Else.Statement);
						output.Indent--;
					}
					else
					{
						var elseBlock = e.Else.Statement as BlockSyntax;
                        output.Write("begin");
                        GenerateTriviaListSyntax(elseBlock.OpenBraceToken.TrailingTrivia, true);

                        output.Indent++;

						foreach (StatementSyntax statement in elseBlock.Statements)
						{
							GenerateStatementSyntax(statement);
						}
						GenerateTriviaListSyntax(elseBlock.CloseBraceToken.LeadingTrivia, false);

						output.Indent--;
                        output.Write("end;");
                        GenerateTriviaListSyntax(elseBlock.CloseBraceToken.TrailingTrivia, true);
                    }
                }
			}
			else
			{

				if (e.Statement.IsKind(SyntaxKind.Block))
				{
					output.Write("end;");
					GenerateTriviaListSyntax(e.GetTrailingTrivia(), true);
				}

			}

		}

        public void GenerateTypes(BaseNamespaceDeclarationSyntax e)
		{
			foreach (var type in e.Members)
			{
				if (type is DelegateDeclarationSyntax)
				{
					output.WriteLine("");
					GenerateDelegateDeclarationSyntax(type as DelegateDeclarationSyntax);
				}
				if (type is EnumDeclarationSyntax)
				{
					output.WriteLine("");
					GenerateEnumType(type as EnumDeclarationSyntax);
				}
				else if (type is InterfaceDeclarationSyntax)
				{
					output.WriteLine("");
					GenerateInterfaceType(type as InterfaceDeclarationSyntax);
				}
				else if (type is StructDeclarationSyntax)
				{
					output.WriteLine("");
					GenerateStructType(type as StructDeclarationSyntax, declaration: true);
				}
				else if (type is ClassDeclarationSyntax)
				{
					output.WriteLine("");
					GenerateClassType(type as ClassDeclarationSyntax, declaration: true);
				}
			}

		}

		private void GenerateFieldDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
			var fieldDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<FieldDeclarationSyntax>();
			foreach (FieldDeclarationSyntax fieldDeclarationSyntax in fieldDeclarationSyntaxCollection)
				GenerateFieldDeclarationSyntax(fieldDeclarationSyntax);
		}

		private void GeneratePropertyDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
			var propertyDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<PropertyDeclarationSyntax>();
			foreach (PropertyDeclarationSyntax propertyDeclarationSyntax in propertyDeclarationSyntaxCollection)
			{

				if (propertyDeclarationSyntax.ExpressionBody is ArrowExpressionClauseSyntax)
				{
					GenerateArrowExpressionClauseSyntaxForPropertyDeclarationSyntax(propertyDeclarationSyntax);
				}
				else if (propertyDeclarationSyntax.AccessorList != null)
				{
					GeneratePropertyDeclarationSyntax(propertyDeclarationSyntax);
				}
			}

		}

		private void GenerateConstructorDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
			var constructorDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<ConstructorDeclarationSyntax>();
			foreach (ConstructorDeclarationSyntax constructorDeclarationSyntax in constructorDeclarationSyntaxCollection)
				GenerateConstructorDeclarationSyntax(constructorDeclarationSyntax, constructorDeclarationSyntaxCollection.Count() > 1, true);
		}

        private void GenerateDestructorDeclarations(TypeDeclarationSyntax typeDeclaration)
        {
            var destructorDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<DestructorDeclarationSyntax>();
            foreach (DestructorDeclarationSyntax destructorDeclarationSyntax in destructorDeclarationSyntaxCollection)
                GenerateDestructorDeclarationSyntax(destructorDeclarationSyntax, destructorDeclarationSyntaxCollection.Count() > 1, true);
        }

        private void GenerateMethodDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
			var methodDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<MethodDeclarationSyntax>();
			foreach (MethodDeclarationSyntax methodDeclarationSyntax in methodDeclarationSyntaxCollection)
			{
				var isOverloaded = false;
				foreach (MethodDeclarationSyntax itemContagemOverload in methodDeclarationSyntaxCollection)
				{
					if (!itemContagemOverload.Equals(methodDeclarationSyntax) && itemContagemOverload.Identifier.ValueText.Equals(methodDeclarationSyntax.Identifier.ValueText))
						isOverloaded = true;
				}

				GenerateMethodDeclarationSyntax(methodDeclarationSyntax, isOverloaded, true);
			}
		}

		private void GenerateIndexerDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
			var indexerDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<IndexerDeclarationSyntax>();
			foreach (IndexerDeclarationSyntax indexerDeclarationSyntax in indexerDeclarationSyntaxCollection)
			{
				if (!indexerDeclarationSyntax.Parent.Equals(typeDeclaration))
					continue;

				if (indexerDeclarationSyntax.ExpressionBody is ArrowExpressionClauseSyntax)
				{
					FileLinePositionSpan span = indexerDeclarationSyntax.SyntaxTree.GetLineSpan(indexerDeclarationSyntax.Span);
					int lineNumber = span.StartLinePosition.Line + 1;

					output.WriteLine();
					output.WriteLine("  //");
					output.WriteLine("  // (indexerDeclarationSyntax.ExpressionBody is ArrowExpressionClauseSyntax)");
					output.WriteLine("  //");
					output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + indexerDeclarationSyntax.ExpressionBody.ToFullString());
                    output.WriteLine("  // Kind: " + indexerDeclarationSyntax.Kind().ToString());
                    output.WriteLine("  // Type: " + indexerDeclarationSyntax.GetType().Name);
                    output.WriteLine("  // Arquivo: " + indexerDeclarationSyntax.SyntaxTree.FilePath);
					output.WriteLine("  // Posição: " + indexerDeclarationSyntax.FullSpan.ToString());
					output.WriteLine("  // Linha: " + lineNumber.ToString());
					output.WriteLine("  //");
					output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
					output.WriteLine(indexerDeclarationSyntax.ToFullString());
					output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 3 ------------");
					output.WriteLine("  //");
				}
				else if (indexerDeclarationSyntax.AccessorList != null)
				{
					GenerateIndexerDeclarationSyntax(indexerDeclarationSyntax);
				}
				else
				{
					throw new NotImplementedException("verificar aqui - E002");
				}
			}
		}

		private void GenerateOperatorDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
            var operatorDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<OperatorDeclarationSyntax>();
			foreach (OperatorDeclarationSyntax operatorDeclarationSyntax in operatorDeclarationSyntaxCollection)
				GenerateOperatorDeclarationSyntax(operatorDeclarationSyntax, true);
		}

        private void GenerateConversionOperatorDeclarations(TypeDeclarationSyntax typeDeclaration)
        {
            var conversionOperatorDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<ConversionOperatorDeclarationSyntax>();
            foreach (ConversionOperatorDeclarationSyntax conversionOperatorDeclarationSyntax in conversionOperatorDeclarationSyntaxCollection)
                GenerateConversionOperatorDeclarationSyntax(conversionOperatorDeclarationSyntax, true);
        }

        private void GenerateStructDeclarationIdentifier(StructDeclarationSyntax structDeclaration)
		{
            output.Write(CSharpToObjectPascalType(structDeclaration.Identifier.ValueText));


            if (structDeclaration.TypeParameterList != null)
				output.Write(structDeclaration.TypeParameterList.ToString());

			output.Write(" = record");

			if (structDeclaration.BaseList != null)
			{
				output.Write("(*");

				foreach (BaseTypeSyntax baseTypeSyntax in structDeclaration.BaseList.Types)
				{
					output.Write(CSharpToObjectPascalType(baseTypeSyntax.Type));

					if (!baseTypeSyntax.Equals(structDeclaration.BaseList.Types.Last()))
					{
						output.Write(", ");
					}

				}

				output.Write("*)");
			}


			if (structDeclaration.Modifiers.IndexOf(SyntaxKind.SealedKeyword) > -1)
				output.Write(" (* sealed *)");

			if (structDeclaration.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write(" (* static *)");

			if (structDeclaration.Modifiers.IndexOf(SyntaxKind.PartialKeyword) > -1)
				output.Write(" (* partial *)");
		}

		private void GenerateNestedInnerClassDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
            var internalClassDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<ClassDeclarationSyntax>();
            foreach (ClassDeclarationSyntax internalClassDeclarationSyntax in internalClassDeclarationSyntaxCollection)
            {
                if (!internalClassDeclarationSyntax.Parent.Equals(typeDeclaration))
                    continue;

				if (internalClassDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
					output.WriteLine("public type");
				else if (internalClassDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
					output.WriteLine("strict private type");
				else
				{
					if (typeDeclaration is StructDeclarationSyntax)
						output.WriteLine("strict private type");
					else
						output.WriteLine("strict protected type");
				}

                output.Indent++;
                output.Indent++;
                GenerateClassType(internalClassDeclarationSyntax, true);
                output.Indent--;
                output.Indent--;
            }
        }

		private void GenerateNestedInnerStructDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
            var internalStructDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<StructDeclarationSyntax>();
            foreach (StructDeclarationSyntax internalStructDeclarationSyntax in internalStructDeclarationSyntaxCollection)
            {
                if (!internalStructDeclarationSyntax.Parent.Equals(typeDeclaration))
                    continue;


                if (internalStructDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
                    output.WriteLine("public type");
                else if (internalStructDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
                    output.WriteLine("strict private type");
                else
                {
					if (typeDeclaration is StructDeclarationSyntax)
						output.WriteLine("strict private type");
					else
						output.WriteLine("strict protected type");
				}

                output.Indent++;
                output.Indent++;
                GenerateStructType(internalStructDeclarationSyntax, true);
                output.Indent--;
                output.Indent--;
				output.WriteLine();
			}
		}

		private void GenerateNestedInnerEnumDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
            var internalEnumDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<EnumDeclarationSyntax>();
            foreach (EnumDeclarationSyntax internalEnumDeclarationSyntax in internalEnumDeclarationSyntaxCollection)
            {
                if (!internalEnumDeclarationSyntax.Parent.Equals(typeDeclaration))
                    continue;

                if (internalEnumDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
                    output.WriteLine("public type");
                else if (internalEnumDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
                    output.WriteLine("strict private type");
                else
                    output.WriteLine("strict protected type");

                output.Indent++;
                output.Indent++;
                GenerateEnumType(internalEnumDeclarationSyntax);
                output.Indent--;
                output.Indent--;
            }
        }

		private void GenerateNestedInnerDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
			GenerateNestedInnerEnumDeclarations(typeDeclaration);
			GenerateNestedInnerClassDeclarations(typeDeclaration);
			GenerateNestedInnerStructDeclarations(typeDeclaration);
		}

		private void GenerateEventDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
			var eventFieldDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<EventFieldDeclarationSyntax>();
			foreach (EventFieldDeclarationSyntax eventFieldDeclarationSyntax in eventFieldDeclarationSyntaxCollection)
			{
				if (!eventFieldDeclarationSyntax.Parent.Equals(typeDeclaration))
					continue;

				GenerateEventFieldDeclarationSyntax(eventFieldDeclarationSyntax);
			}
		}

		private void GenerateDelegateDeclarations(TypeDeclarationSyntax typeDeclaration)
		{
			var delegateDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<DelegateDeclarationSyntax>();
			foreach (DelegateDeclarationSyntax delegateDeclarationSyntax in delegateDeclarationSyntaxCollection)
			{
				if (!delegateDeclarationSyntax.Parent.Equals(typeDeclaration))
					continue;

				GenerateDelegateDeclarationSyntax(delegateDeclarationSyntax);
			}
		}

		internal void GenerateTypeDeclarations(TypeDeclarationSyntax typeDeclaration)
        {
            var currentIndent = output.Indent;
			output.Indent = 0;
            output.WriteLine();
            output.Write("{$REGION '");
            output.Write(CSharpToObjectPascalType(typeDeclaration.Identifier.ValueText));
            output.WriteLine("'}");
            output.Indent = currentIndent;

            output.WriteLine();
            output.Write("{ ");

            output.Write(CSharpToObjectPascalType(typeDeclaration.Identifier.ValueText));

            if (typeDeclaration.TypeParameterList != null)
				output.Write(typeDeclaration.TypeParameterList.ToString());
			output.WriteLine(" }");

            output.WriteLine();

            GenerateLeadingTriviaSyntax(typeDeclaration);
            GenerateAttributes(typeDeclaration.AttributeLists);

            if (typeDeclaration is StructDeclarationSyntax structDeclaration)
				GenerateStructDeclarationIdentifier(structDeclaration);
			else if (typeDeclaration is ClassDeclarationSyntax)
				GenerateClassDeclarationIdentifier(typeDeclaration as ClassDeclarationSyntax);
			else
				throw new NotSupportedException();

            GenerateTriviaListSyntax(typeDeclaration.Identifier.TrailingTrivia, true);
            GenerateTriviaListSyntax(typeDeclaration.OpenBraceToken.TrailingTrivia, true);
            GenerateTriviaListSyntax(typeDeclaration.OpenBraceToken.LeadingTrivia, true);

            Indent++;

			GenerateNestedInnerDeclarations(typeDeclaration);
			GenerateFieldDeclarations(typeDeclaration);

			if (typeDeclaration is ClassDeclarationSyntax)
			{
                GenerateStaticClassConstruction(typeDeclaration as ClassDeclarationSyntax, true);
                GenerateStaticClassDestruction(typeDeclaration as ClassDeclarationSyntax, true);
                GenerateAfterConstruction(typeDeclaration as ClassDeclarationSyntax, true);
				GenerateBeforeDestruction(typeDeclaration as ClassDeclarationSyntax, true);
				output.WriteLine();
			}

			GeneratePropertyDeclarations(typeDeclaration);
			GenerateConstructorDeclarations(typeDeclaration);
            GenerateDestructorDeclarations(typeDeclaration);
            GenerateMethodDeclarations(typeDeclaration);
			GenerateIndexerDeclarations(typeDeclaration);
			GenerateEventDeclarations(typeDeclaration);
			GenerateDelegateDeclarations(typeDeclaration);
			GenerateOperatorDeclarations(typeDeclaration);
            GenerateConversionOperatorDeclarations(typeDeclaration);

            output.Indent--;
			output.Write("end;");

            GenerateTriviaListSyntax(typeDeclaration.CloseBraceToken.TrailingTrivia, true);

            currentIndent = output.Indent;
            output.Indent = 0;
            output.WriteLine();
            output.Write("{$ENDREGION '");
            output.Write(CSharpToObjectPascalType(typeDeclaration.Identifier.ValueText));
            output.WriteLine("'}");
            output.Indent = currentIndent;
        }


        private void GeneratePropertyImplementations(TypeDeclarationSyntax typeDeclaration)
		{
			var propertyDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<PropertyDeclarationSyntax>();
			foreach (PropertyDeclarationSyntax propertyDeclarationSyntax in propertyDeclarationSyntaxCollection)
			{
				GenerateImplementationPropertyDeclarationSyntax(propertyDeclarationSyntax);
			}
		}

		private void GenerateConstructorImplementations(TypeDeclarationSyntax typeDeclaration)
		{
			var constructorDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<ConstructorDeclarationSyntax>();
			foreach (ConstructorDeclarationSyntax constructorDeclarationSyntax in constructorDeclarationSyntaxCollection)
			{
				output.WriteLine();
				GenerateConstructorDeclarationSyntax(constructorDeclarationSyntax, constructorDeclarationSyntaxCollection.Count() > 1, false);

				output.WriteLine("begin");
				if (constructorDeclarationSyntax.Initializer != null)
				{
					GenerateConstructorInitializerSyntax(constructorDeclarationSyntax.Initializer);
					output.WriteLine();
				}


				if (constructorDeclarationSyntax.Body != null)
					GenerateMethodBodySyntax(constructorDeclarationSyntax.Body);
				else if (constructorDeclarationSyntax.ExpressionBody != null)
				{
					output.Indent++;

					GenerateExpressionSyntax(constructorDeclarationSyntax.ExpressionBody.Expression);
					output.WriteLine(";");

					output.Indent--;
				}


				output.WriteLine("end;");
			}
		}

        private void GenerateDestructorImplementations(TypeDeclarationSyntax typeDeclaration)
        {
            var destructorDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<DestructorDeclarationSyntax>();
            foreach (DestructorDeclarationSyntax destructorDeclarationSyntax in destructorDeclarationSyntaxCollection)
            {
                output.WriteLine();
                GenerateDestructorDeclarationSyntax(destructorDeclarationSyntax, destructorDeclarationSyntaxCollection.Count() > 1, false);

                output.WriteLine("begin");

                if (destructorDeclarationSyntax.Body != null)
                    GenerateMethodBodySyntax(destructorDeclarationSyntax.Body);
                else if (destructorDeclarationSyntax.ExpressionBody != null)
                {
                    output.Indent++;

                    GenerateExpressionSyntax(destructorDeclarationSyntax.ExpressionBody.Expression);
                    output.WriteLine(";");

                    output.WriteLine("inherited Destroy();");
                    output.Indent--;
                }


                output.WriteLine("end;");
            }
        }

        private void GenerateLocalFunctionDeclaration(LocalFunctionStatementSyntax localFunction)
        {

			GenerateCommentsTrivia(localFunction);
			GenerateAttributes(localFunction.AttributeLists);

            if (!localFunction.ReturnType.ToString().Equals("void"))
				output.Write("function ");
			else
				output.Write("procedure ");

			output.Write(CodeGenUtils.CreateEscapedIdentifier(localFunction.Identifier.ValueText));
			if (localFunction.TypeParameterList != null)
				output.Write(localFunction.TypeParameterList.ToString());

			output.Write("(");

			if (localFunction.ParameterList != null)
			{
				SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = localFunction.ParameterList.Parameters;
				foreach (ParameterSyntax param in parameterSyntaxCollection)
				{

					if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
						output.Write("const ");
					else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
						output.Write("var ");
					else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
						output.Write("out ");
					else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
						output.Write("const ");
					else if (param.Modifiers.IndexOf(SyntaxKind.ThisKeyword) > -1)
						output.Write("(*Self*) const [ref] ");
					else
						output.Write("const ");

					output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.ValueText));
					output.Write(": " + CSharpToObjectPascalType(param.Type));

					if (param.Default != null)
					{
						output.Write(" = ");
						GenerateExpressionSyntax(param.Default.Value);
					}


					if (!param.Equals(parameterSyntaxCollection.Last()))
						output.Write("; ");
				}

			}


			output.Write(")");

			if (!localFunction.ReturnType.ToString().Equals("void"))
				output.Write(": " + CSharpToObjectPascalType(localFunction.ReturnType));

			output.WriteLine(";");
		}

		private void GenerateLocalFunction(LocalFunctionStatementSyntax localFunction)
		{
			output.WriteLine();
			GenerateLocalFunctionDeclaration(localFunction);

			if (localFunction.Body != null)
			{
				GenerateLocalFunctions(localFunction.Body.ChildNodes().OfType<LocalFunctionStatementSyntax>());
				GenerateLabeledStatementsDeclarations(localFunction.Body.ChildNodes().OfType<LabeledStatementSyntax>());
			}

			output.WriteLine("begin");

			if (localFunction.Body != null)
				GenerateBlockSyntax(localFunction.Body);
			else if (localFunction.ExpressionBody != null)
			{
				output.Indent++;

				if (!localFunction.ReturnType.ToString().Equals("void"))
					output.Write("Result := ");
				GenerateExpressionSyntax(localFunction.ExpressionBody.Expression);
				output.WriteLine(";");

				output.Indent--;
			}

			output.WriteLine("end;");
			output.WriteLine();
		}

		private void GenerateLocalFunctions(IEnumerable<LocalFunctionStatementSyntax> localFunctionCollection)
		{
			foreach (LocalFunctionStatementSyntax localFunction in localFunctionCollection)
			{
				if (localFunctionCollection.First() == localFunction)
				{
					output.Indent++;
					output.Indent++;
				}

				GenerateLocalFunction(localFunction);

				if (localFunctionCollection.Last() == localFunction)
				{
					output.Indent--;
					output.Indent--;
					output.WriteLine();
				};

			}
		}


        private void GenerateLabeledStatementsDeclarations(IEnumerable<LabeledStatementSyntax> labeledStatementCollection)
		{
			foreach (LabeledStatementSyntax labeledStatementSyntax in labeledStatementCollection)
			{
				if (labeledStatementCollection.First() == labeledStatementSyntax)
				{
					output.WriteLine("label");
					output.Indent++;
				}

				output.Write(labeledStatementSyntax.Identifier.ToString());

				if (labeledStatementCollection.Last() == labeledStatementSyntax)
				{
					output.WriteLine(";");
					output.Indent--;
				}
				else
				{
					output.WriteLine(",");
				}
			}

		}

		private void GenerateMethodimplementation(MethodDeclarationSyntax methodDeclarationSyntax)
		{
			if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.AbstractKeyword) > -1)
				return;
			
			output.WriteLine();
			GenerateMethodDeclarationSyntax(methodDeclarationSyntax, false, false);

			if (methodDeclarationSyntax.Identifier.ToString() == "SetNativeBrush")
			{

			}

            if (methodDeclarationSyntax.Body != null)
			{
				GenerateLocalFunctions(methodDeclarationSyntax.Body.ChildNodes().OfType<LocalFunctionStatementSyntax>());
				GenerateLabeledStatementsDeclarations(methodDeclarationSyntax.Body.ChildNodes().OfType<LabeledStatementSyntax>());
			}

			
			if (methodDeclarationSyntax.Body != null)
			{
                GenerateBlockSyntax(methodDeclarationSyntax.Body);
			}
			else if (methodDeclarationSyntax.ExpressionBody != null)
			{
                //output.WriteLine();
                output.WriteLine("begin");
                output.Indent++;

				if (!methodDeclarationSyntax.ReturnType.ToString().Equals("void"))
					output.Write("Result := ");
				GenerateExpressionSyntax(methodDeclarationSyntax.ExpressionBody.Expression);
				output.WriteLine();

				output.Indent--;
                output.WriteLine("end;");
            }

        }


        private void GenerateMethodImplementations(TypeDeclarationSyntax typeDeclaration)
		{
			var methodDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<MethodDeclarationSyntax>();
			foreach (MethodDeclarationSyntax methodDeclarationSyntax in methodDeclarationSyntaxCollection)
			{
				GenerateMethodimplementation(methodDeclarationSyntax);
			}
		}


        private void GenerateOperatorImplementations(TypeDeclarationSyntax typeDeclaration)
		{
			var operatorDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<OperatorDeclarationSyntax>();
			foreach (OperatorDeclarationSyntax operatorDeclarationSyntax in operatorDeclarationSyntaxCollection)
			{
				output.WriteLine();
				GenerateOperatorDeclarationSyntax(operatorDeclarationSyntax, false);

				output.WriteLine("begin");

				if (operatorDeclarationSyntax.Body != null)
					GenerateBlockSyntax(operatorDeclarationSyntax.Body);
				else if (operatorDeclarationSyntax.ExpressionBody != null)
				{
					output.Indent++;

					if (!operatorDeclarationSyntax.ReturnType.ToString().Equals("void"))
						output.Write("Result := ");
					
					GenerateArrowExpressionClauseSyntax(operatorDeclarationSyntax.ExpressionBody);
					output.WriteLine(";");

					output.Indent--;
				}

				output.WriteLine("end;");

			}
		}

        private void GenerateConversionOperatorImplementations(TypeDeclarationSyntax typeDeclaration)
        {
            var conversionOperatorDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<ConversionOperatorDeclarationSyntax>();
            foreach (ConversionOperatorDeclarationSyntax conversionOperatorDeclarationSyntax in conversionOperatorDeclarationSyntaxCollection)
            {
                output.WriteLine();
                GenerateConversionOperatorDeclarationSyntax(conversionOperatorDeclarationSyntax, false);

                if (conversionOperatorDeclarationSyntax.Body != null)
                    GenerateBlockSyntax(conversionOperatorDeclarationSyntax.Body);
                else if (conversionOperatorDeclarationSyntax.ExpressionBody != null)
                {
                    output.WriteLine("begin");
                    output.Indent++;

                    output.Write("Result := ");
                    GenerateArrowExpressionClauseSyntax(conversionOperatorDeclarationSyntax.ExpressionBody);
                    output.WriteLine(";");

                    output.Indent--;
                    output.WriteLine("end;");
                }


            }
        }

        private void GenerateArrowExpressionClauseSyntax(ArrowExpressionClauseSyntax expressionBody)
        {
			GenerateExpressionSyntax(expressionBody.Expression);
		}

		private void GenerateIndexerImplementation(IndexerDeclarationSyntax indexerDeclarationSyntax)
		{
			var qualifiedNames = new List<string>();

			if (indexerDeclarationSyntax.Parent is ClassDeclarationSyntax)
			{
				ClassDeclarationSyntax classDeclarationSyntax = indexerDeclarationSyntax.Parent as ClassDeclarationSyntax;

				qualifiedNames.Add(CSharpToObjectPascalType(classDeclarationSyntax.Identifier.ValueText));
				if (classDeclarationSyntax.TypeParameterList != null)
					qualifiedNames[0] += classDeclarationSyntax.TypeParameterList.ToString();

				var parentClass = classDeclarationSyntax.Parent as ClassDeclarationSyntax;

				while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
				{
					qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
					parentClass = parentClass.Parent as ClassDeclarationSyntax;
				}
			}
			else if (indexerDeclarationSyntax.Parent is StructDeclarationSyntax)
			{
				StructDeclarationSyntax structDeclarationSyntax = indexerDeclarationSyntax.Parent as StructDeclarationSyntax;

				qualifiedNames.Add(CSharpToObjectPascalType(structDeclarationSyntax.Identifier.ValueText));
				if (structDeclarationSyntax.TypeParameterList != null)
					qualifiedNames[0] += structDeclarationSyntax.TypeParameterList.ToString();

				var parentStruct = structDeclarationSyntax.Parent as StructDeclarationSyntax;

				while (parentStruct != null && parentStruct.Kind() == SyntaxKind.StructDeclaration)
				{
					qualifiedNames.Insert(0, CSharpToObjectPascalType(parentStruct.Identifier.ValueText));
					parentStruct = parentStruct.Parent as StructDeclarationSyntax;
				}
			}


			SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = indexerDeclarationSyntax.ParameterList.Parameters;
			foreach (AccessorDeclarationSyntax accessorDeclarationSyntax in indexerDeclarationSyntax.AccessorList.Accessors)
			{
				if (accessorDeclarationSyntax.IsKind(SyntaxKind.GetAccessorDeclaration))
				{

					if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
						output.Write("class ");

					output.Write("function ");

					foreach (var item in qualifiedNames)
					{
						output.Write(item);

						//if (!item.Equals(qualifiedNames.Last()))
						{
							output.Write(".");
						}
					}

					output.Write("GetItem(");

					foreach (ParameterSyntax param in parameterSyntaxCollection)
					{
						GenerateParameterSyntax(param);

						if (!param.Equals(parameterSyntaxCollection.Last()))
							output.Write("; ");
					}

					output.Write("): " + CSharpToObjectPascalType(indexerDeclarationSyntax.Type));

					output.WriteLine(";");

					output.WriteLine("begin");

					if (accessorDeclarationSyntax.Body != null)
						GenerateBlockSyntax(accessorDeclarationSyntax.Body);
					else if (accessorDeclarationSyntax.ExpressionBody != null)
					{
						output.Indent++;
						output.Write("Result := ");
						GenerateExpressionSyntax(accessorDeclarationSyntax.ExpressionBody.Expression);
						output.WriteLine(";");
						output.Indent--;
					}

					output.WriteLine("end;");
					output.WriteLine();

				}
				else if (accessorDeclarationSyntax.IsKind(SyntaxKind.SetAccessorDeclaration))
				{
					//if (accessorDeclarationSyntax.Body != null) // auto property
					{

						if (indexerDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("class ");


						output.Write("procedure ");

						foreach (var item in qualifiedNames)
						{
							output.Write(item);

							//if (!item.Equals(qualifiedNames.Last()))
							{
								output.Write(".");
							}
						}

						output.Write("SetItem(");


						foreach (ParameterSyntax param in parameterSyntaxCollection)
						{
							if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
								output.Write("const ");
							else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
								output.Write("var ");
							else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
								output.Write("out ");
							else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
								output.Write("const ");
							else
								output.Write("const ");

							output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.Text));
							output.Write(": " + CSharpToObjectPascalType(param.Type));

							output.Write("; ");
						}


						output.Write("const Value: " + CSharpToObjectPascalType(indexerDeclarationSyntax.Type) + ")");

						output.WriteLine(";");

						output.WriteLine("begin");

						if (accessorDeclarationSyntax.Body != null)
							GenerateBlockSyntax(accessorDeclarationSyntax.Body);
						else if (accessorDeclarationSyntax.ExpressionBody != null)
						{
							output.Indent++;
							GenerateExpressionSyntax(accessorDeclarationSyntax.ExpressionBody.Expression);
							output.Indent--;
						}

						output.WriteLine("end;");
					}
				}
				else
				{
                    var node = accessorDeclarationSyntax;
                    var kind = node.Kind();
                    FileLinePositionSpan span = node.SyntaxTree.GetLineSpan(node.Span);
                    int lineNumber = span.StartLinePosition.Line + 1;

                    output.WriteLine();
                    output.WriteLine("  //");
                    output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                    output.WriteLine("  // Kind: " + node.Kind().ToString());
                    output.WriteLine("  // Type: " + node.GetType().Name);
                    output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                    output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                    output.WriteLine("  // Linha: " + lineNumber.ToString());
                    output.WriteLine("  //");
                    output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                    output.WriteLine(node.ToFullString());
                    output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 04/03/2024-5 ------------");
                    output.WriteLine("  //");
                }
            }
		}

		private void GenerateIndexerImplementations(TypeDeclarationSyntax typeDeclaration)
		{
			var indexerDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<IndexerDeclarationSyntax>();
			foreach (IndexerDeclarationSyntax indexerDeclarationSyntax in indexerDeclarationSyntaxCollection)
			{
				if (!indexerDeclarationSyntax.Parent.Equals(typeDeclaration))
					continue;

				if (indexerDeclarationSyntax.ExpressionBody is ArrowExpressionClauseSyntax)
				{
					FileLinePositionSpan span = indexerDeclarationSyntax.SyntaxTree.GetLineSpan(indexerDeclarationSyntax.Span);
					int lineNumber = span.StartLinePosition.Line + 1;

					output.WriteLine();
					output.WriteLine("  //");
					output.WriteLine("  // (indexerDeclarationSyntax.ExpressionBody is ArrowExpressionClauseSyntax)");
					output.WriteLine("  //");
					output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + indexerDeclarationSyntax.ExpressionBody.ToFullString());
                    output.WriteLine("  // Kind: " + indexerDeclarationSyntax.Kind().ToString());
                    output.WriteLine("  // Type: " + indexerDeclarationSyntax.GetType().Name);
                    output.WriteLine("  // Arquivo: " + indexerDeclarationSyntax.SyntaxTree.FilePath);
					output.WriteLine("  // Posição: " + indexerDeclarationSyntax.FullSpan.ToString());
					output.WriteLine("  // Linha: " + lineNumber.ToString());
					output.WriteLine("  //");
					output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
					output.WriteLine(indexerDeclarationSyntax.ToFullString());
					output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 3 ------------");
					output.WriteLine("  //");
				}
				else if (indexerDeclarationSyntax.AccessorList != null)
				{
					GenerateIndexerImplementation(indexerDeclarationSyntax);
				}
				else
				{
					throw new NotImplementedException("verificar aqui - E00301");
				}
			}
		}


        private void GenerateNestedInnerStructImplementations(TypeDeclarationSyntax typeDeclaration)
		{
			var internalStructDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<StructDeclarationSyntax>();
			foreach (StructDeclarationSyntax internalStructDeclarationSyntax in internalStructDeclarationSyntaxCollection)
			{
				if (!internalStructDeclarationSyntax.Parent.Equals(typeDeclaration))
					continue;

				GenerateStructType(internalStructDeclarationSyntax, false);
			}
		}

		private void GenerateNestedInnerClassImplementations(TypeDeclarationSyntax typeDeclaration)
		{
			var internalClassDeclarationSyntaxCollection = typeDeclaration.ChildNodes().OfType<ClassDeclarationSyntax>();
			foreach (ClassDeclarationSyntax internalClassDeclarationSyntax in internalClassDeclarationSyntaxCollection)
			{
				if (!internalClassDeclarationSyntax.Parent.Equals(typeDeclaration))
					continue;

				GenerateClassType(internalClassDeclarationSyntax, false);
			}
		}

		private void GenerateNestedInnerImplementations(TypeDeclarationSyntax typeDeclaration)
		{
			GenerateNestedInnerClassImplementations(typeDeclaration);
			GenerateNestedInnerStructImplementations(typeDeclaration);
		}


		private void GenerateTypeImplementations(TypeDeclarationSyntax typeDeclaration)
		{
            var currentIndent = output.Indent;
			output.Indent = 0;
            output.WriteLine();
            output.Write("{$REGION '");
            output.Write(CSharpToObjectPascalType(typeDeclaration.Identifier.ValueText));
            output.WriteLine("'}");
            output.Indent = currentIndent;

            GenerateNestedInnerImplementations(typeDeclaration);


			output.WriteLine();
			output.Write("{ ");

            output.Write(CSharpToObjectPascalType(typeDeclaration.Identifier.ValueText));


            if (typeDeclaration.TypeParameterList != null)
				output.Write(typeDeclaration.TypeParameterList.ToString());
			output.WriteLine(" }");


			if (typeDeclaration is ClassDeclarationSyntax classDeclaration)
			{
                GenerateStaticClassConstruction(typeDeclaration as ClassDeclarationSyntax, false);
                GenerateStaticClassDestruction(typeDeclaration as ClassDeclarationSyntax, false);
                GenerateAfterConstruction(classDeclaration, false);
				GenerateBeforeDestruction(classDeclaration, false);
			}

			GeneratePropertyImplementations(typeDeclaration);
			GenerateConstructorImplementations(typeDeclaration);
            GenerateDestructorImplementations(typeDeclaration);
            GenerateMethodImplementations(typeDeclaration);
			GenerateIndexerImplementations(typeDeclaration);
			GenerateOperatorImplementations(typeDeclaration);
            GenerateConversionOperatorImplementations(typeDeclaration);

            currentIndent = output.Indent;
            output.Indent = 0;
            output.WriteLine();
            output.Write("{$ENDREGION '");
            output.Write(CSharpToObjectPascalType(typeDeclaration.Identifier.ValueText));
            output.WriteLine("'}");
            output.Indent = currentIndent;
        }

        internal void GenerateStructType(StructDeclarationSyntax e, bool declaration)
        {
			if (declaration)
			{
				GenerateTypeDeclarations(e);
			}
			else
			{
				GenerateTypeImplementations(e);
			}
		}


        private void GenerateOperatorDeclarationSyntax(OperatorDeclarationSyntax operatorDeclaration, bool declaration)
        {
			if (declaration)
			{
				GenerateCommentsTrivia(operatorDeclaration);
				GenerateAttributes(operatorDeclaration.AttributeLists);
			}

			output.Write("class operator ");

			if (!declaration)
			{

					var qualifiedNames = new List<string>();
				if (operatorDeclaration.Parent is TypeDeclarationSyntax)
				{
					TypeDeclarationSyntax typeDeclarationSyntax = operatorDeclaration.Parent as TypeDeclarationSyntax;

					qualifiedNames.Add(CSharpToObjectPascalType(typeDeclarationSyntax.Identifier.ValueText));
					if (typeDeclarationSyntax.TypeParameterList != null)
						qualifiedNames[0] += typeDeclarationSyntax.TypeParameterList.ToString();

					var parentType = typeDeclarationSyntax.Parent as TypeDeclarationSyntax;

					while (parentType != null)
					{
						qualifiedNames.Insert(0, CSharpToObjectPascalType(parentType.Identifier.ValueText));
						parentType = parentType.Parent as TypeDeclarationSyntax;
					}
				}

				foreach (var item in qualifiedNames)
				{
					output.Write(item);

					if (!item.Equals(qualifiedNames.Last()))
					{
						output.Write(".");
					}
				}


				output.Write(".");
			}

			if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.EqualsEqualsToken))
            {
				output.Write("Equal"); // =
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.ExclamationEqualsToken))
            {
				output.Write("NotEqual"); // not =
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.LessThanToken))
			{
				output.Write("LessThan"); // <
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.GreaterThanToken))
			{
				output.Write("GreaterThan"); // >
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.LessThanEqualsToken))
			{
				output.Write("LessThanOrEqual"); // <=
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.GreaterThanEqualsToken))
			{
				output.Write("GreaterThanOrEqual");  // >=
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.PlusToken))
			{
				if (operatorDeclaration.ParameterList.Parameters.Count == 1)
					output.Write("Positive");  // +
				else
					output.Write("Add");  // +
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.MinusToken))
			{
				if (operatorDeclaration.ParameterList.Parameters.Count == 1)
					output.Write("Negative");  // -
				else
					output.Write("Subtract");  // -
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.AsteriskToken))
			{
				output.Write("Multiply");  // *
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.SlashToken))
			{
				output.Write("Divide");  // /
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.PercentToken))
			{
				output.Write("Modulus");  // % (resto da divisão)
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.PlusPlusToken))
			{
				output.Write("Inc");  // ++
			}
			else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.MinusMinusToken))
			{
				output.Write("Dec");  // --
			}
            else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.ExclamationToken))
            {
                output.Write("!");  // --
            }
            else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.TrueKeyword))
            {
                output.Write("true");  // --
            }
            else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.OperatorDeclaration))
            {
                output.Write(operatorDeclaration.OperatorToken.ValueText);  // --
            }
            else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.FalseKeyword))
            {
                output.Write("false");  // --
            }
            else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.AmpersandToken))
            {
                output.Write(operatorDeclaration.OperatorToken.ValueText);  // --
            }
            else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.TildeToken))
            {
                output.Write(operatorDeclaration.OperatorToken.ValueText);  // --
            }
            else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.BarToken))
            {
                output.Write(operatorDeclaration.OperatorToken.ValueText);  // --
            }
            else if (operatorDeclaration.OperatorToken.IsKind(SyntaxKind.CaretToken))
            {
                output.Write(operatorDeclaration.OperatorToken.ValueText);  // --
            }
            else
            {

                var kind = operatorDeclaration.Kind();
                FileLinePositionSpan span = operatorDeclaration.SyntaxTree.GetLineSpan(operatorDeclaration.Span);
                int lineNumber = span.StartLinePosition.Line + 1;

                output.WriteLine();
                output.WriteLine("  //");
                output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                output.WriteLine("  // Kind: " + operatorDeclaration.Kind().ToString());
                output.WriteLine("  // Type: " + operatorDeclaration.GetType().Name);
                output.WriteLine("  // Arquivo: " + operatorDeclaration.SyntaxTree.FilePath);
                output.WriteLine("  // Posição: " + operatorDeclaration.FullSpan.ToString());
                output.WriteLine("  // Linha: " + lineNumber.ToString());
                output.WriteLine("  //");
                output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                output.WriteLine(operatorDeclaration.ToFullString());
                output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 2222 ------------");
                output.WriteLine("  //");



             //   throw new NotImplementedException("operador não implementado: " + e.OperatorToken.Kind().ToString());
			}

			output.Write("(");

			if (operatorDeclaration.ParameterList != null)
			{
				SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = operatorDeclaration.ParameterList.Parameters;
				foreach (ParameterSyntax param in parameterSyntaxCollection)
				{
					if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
						output.Write("const ");
					else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
						output.Write("var ");
					else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
						output.Write("out ");
					else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
						output.Write("const ");
					else
						output.Write("const ");

					output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.Text));
					output.Write(": " + CSharpToObjectPascalType(param.Type));

					if (!param.Equals(parameterSyntaxCollection.Last()))
						output.Write("; ");
				}

			}


			output.Write(")");

			if (!operatorDeclaration.ReturnType.ToString().Equals("void"))
				output.Write(": " + CSharpToObjectPascalType(operatorDeclaration.ReturnType));

			if (declaration)
            {
				if (operatorDeclaration.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
					output.Write("; static");

                if (ContainsAggressiveInliningMethodImpl(operatorDeclaration.AttributeLists))
                    output.Write("; inline");
            }

            output.WriteLine(";");


		}


        private void GenerateConversionOperatorDeclarationSyntax(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration, bool declaration)
        {
            if (declaration)
            {
                GenerateCommentsTrivia(conversionOperatorDeclaration);
                GenerateAttributes(conversionOperatorDeclaration.AttributeLists);
            }

            output.Write("class operator ");

            if (!declaration)
            {

                var qualifiedNames = new List<string>();
                if (conversionOperatorDeclaration.Parent is TypeDeclarationSyntax)
                {
                    TypeDeclarationSyntax typeDeclarationSyntax = conversionOperatorDeclaration.Parent as TypeDeclarationSyntax;

                    qualifiedNames.Add(CSharpToObjectPascalType(typeDeclarationSyntax.Identifier.ValueText));
                    if (typeDeclarationSyntax.TypeParameterList != null)
                        qualifiedNames[0] += typeDeclarationSyntax.TypeParameterList.ToString();

                    var parentType = typeDeclarationSyntax.Parent as TypeDeclarationSyntax;

                    while (parentType != null)
                    {
                        qualifiedNames.Insert(0, CSharpToObjectPascalType(parentType.Identifier.ValueText));
                        parentType = parentType.Parent as TypeDeclarationSyntax;
                    }
                }

                foreach (var item in qualifiedNames)
                {
                    output.Write(item);

                    if (!item.Equals(qualifiedNames.Last()))
                    {
                        output.Write(".");
                    }
                }


                output.Write(".");
            }

            if (conversionOperatorDeclaration.ImplicitOrExplicitKeyword.IsKind(SyntaxKind.ImplicitKeyword))
            {
                output.Write("implicit");
            }
            else if (conversionOperatorDeclaration.ImplicitOrExplicitKeyword.IsKind(SyntaxKind.ExplicitKeyword))
            {
                output.Write("explicit");
            }
            else
            {

                var kind = conversionOperatorDeclaration.Kind();
                FileLinePositionSpan span = conversionOperatorDeclaration.SyntaxTree.GetLineSpan(conversionOperatorDeclaration.Span);
                int lineNumber = span.StartLinePosition.Line + 1;

                output.WriteLine();
                output.WriteLine("  //");
                output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                output.WriteLine("  // Kind: " + conversionOperatorDeclaration.Kind().ToString());
                output.WriteLine("  // Type: " + conversionOperatorDeclaration.GetType().Name);
                output.WriteLine("  // Arquivo: " + conversionOperatorDeclaration.SyntaxTree.FilePath);
                output.WriteLine("  // Posição: " + conversionOperatorDeclaration.FullSpan.ToString());
                output.WriteLine("  // Linha: " + lineNumber.ToString());
                output.WriteLine("  //");
                output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                output.WriteLine(conversionOperatorDeclaration.ToFullString());
                output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 27/03/2024-01 ------------");
                output.WriteLine("  //");
            }

            output.Write("(");

            if (conversionOperatorDeclaration.ParameterList != null)
            {
                SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = conversionOperatorDeclaration.ParameterList.Parameters;
                foreach (ParameterSyntax param in parameterSyntaxCollection)
                {
                    if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
                        output.Write("const ");
                    else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
                        output.Write("var ");
                    else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
                        output.Write("out ");
                    else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
                        output.Write("const ");
                    else
                        output.Write("const ");

                    output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.Text));
                    output.Write(": " + CSharpToObjectPascalType(param.Type));

                    if (!param.Equals(parameterSyntaxCollection.Last()))
                        output.Write("; ");
                }

            }


            output.Write(")");
            output.Write(": " + CSharpToObjectPascalType(conversionOperatorDeclaration.Type));

            if (declaration)
            {
                if (ContainsAggressiveInliningMethodImpl(conversionOperatorDeclaration.AttributeLists))
                    output.Write("; inline");
            }

            output.WriteLine(";");


        }


        internal void GenerateInterfaceType(InterfaceDeclarationSyntax e)
        {
			if (e.Parent is not ClassDeclarationSyntax)
			{
				output.Write("{ ");
				output.Write(e.Identifier.ValueText);
				output.WriteLine(" }");
				output.WriteLine();
			}

			GenerateCommentsTrivia(e);
            GenerateAttributes(e.AttributeLists);
            GenerateInterfaceDeclarationNameSyntax(e);
			Indent++;

			if (e.Identifier.ValueText.Equals("IDocument"))
            {
				//Console.WriteLine("IDocument");
            }

			var eventFieldDeclarationSyntaxCollection = e.ChildNodes().OfType<EventFieldDeclarationSyntax>();
			foreach (EventFieldDeclarationSyntax eventFieldDeclarationSyntax in eventFieldDeclarationSyntaxCollection)
				GenerateEventFieldDeclarationSyntax(eventFieldDeclarationSyntax);

			var indexerDeclarationSyntaxCollection = e.ChildNodes().OfType<IndexerDeclarationSyntax>();
			foreach (IndexerDeclarationSyntax indexerDeclarationSyntax in indexerDeclarationSyntaxCollection)
			{

				if (indexerDeclarationSyntax.ExpressionBody is ArrowExpressionClauseSyntax)
				{
					//Console.WriteLine("(indexerDeclarationSyntax.ExpressionBody is ArrowExpressionClauseSyntax)");
					throw new NotImplementedException("(indexerDeclarationSyntax.ExpressionBody is ArrowExpressionClauseSyntax)");
				}
				else if (indexerDeclarationSyntax.AccessorList != null)
				{
					GenerateIndexerDeclarationSyntax(indexerDeclarationSyntax);
				}
			}


			var propertyDeclarationSyntaxCollection = e.ChildNodes().OfType<PropertyDeclarationSyntax>();
			foreach (PropertyDeclarationSyntax propertyDeclarationSyntax in propertyDeclarationSyntaxCollection)
			{

				if (propertyDeclarationSyntax.ExpressionBody is ArrowExpressionClauseSyntax)
				{
					GenerateArrowExpressionClauseSyntaxForPropertyDeclarationSyntax(propertyDeclarationSyntax);
				}
				else if (propertyDeclarationSyntax.AccessorList != null)
				{
					GeneratePropertyDeclarationSyntax(propertyDeclarationSyntax);
				}
			}

			var eventDeclarationSyntaxCollection = e.ChildNodes().OfType<EventDeclarationSyntax>();
			foreach (EventDeclarationSyntax eventDeclarationSyntax in eventDeclarationSyntaxCollection)
			{

				if (eventDeclarationSyntax.AccessorList != null)
				{
					GenerateEventDeclarationSyntax(eventDeclarationSyntax);
				}
			}

			var delegateDeclarationSyntaxCollection = e.ChildNodes().OfType<DelegateDeclarationSyntax>();
			foreach (DelegateDeclarationSyntax delegateDeclarationSyntax in delegateDeclarationSyntaxCollection)
			{
				GenerateDelegateDeclarationSyntax(delegateDeclarationSyntax);
			}


			var methodDeclarationSyntaxCollection = e.ChildNodes().OfType<MethodDeclarationSyntax>();
			foreach (MethodDeclarationSyntax methodDeclarationSyntax in methodDeclarationSyntaxCollection)
			{
				var isOverloaded = false;
				foreach (MethodDeclarationSyntax itemContagemOverload in methodDeclarationSyntaxCollection)
				{
					if (!itemContagemOverload.Equals(methodDeclarationSyntax) && itemContagemOverload.Identifier.ValueText.Equals(methodDeclarationSyntax.Identifier.ValueText))
						isOverloaded = true;
				}

				GenerateMethodDeclarationSyntax(methodDeclarationSyntax, isOverloaded, true);
			}


			output.Indent--;
			output.WriteLine("end;");
		}

		protected void GenerateNamespaceDeclarationSyntax(BaseNamespaceDeclarationSyntax e)
		{
			

			var usingDirectiveSyntaxCollection = e.Parent.ChildNodes().OfType<UsingDirectiveSyntax>();
			if (usingDirectiveSyntaxCollection != null && usingDirectiveSyntaxCollection.Count() > 0)
			{
				output.WriteLine("");
				output.WriteLine("uses");
				Indent++;

				foreach (UsingDirectiveSyntax usingDirectiveSyntax in usingDirectiveSyntaxCollection)
				{
					if (usingDirectiveSyntax.Name.ToString().Equals("System"))
						continue;

					output.Write(usingDirectiveSyntax.Name);
					if (usingDirectiveSyntax.Equals(usingDirectiveSyntaxCollection.Last()))
						output.WriteLine(";");
					else
						output.WriteLine(",");
				}

				Indent--;
			}
		}


		protected virtual void GenerateNamespace(BaseNamespaceDeclarationSyntax e, ObjectPascalCodeGeneratorOptions o)
		{
			GenerateNamespaceStart(e, o);
			GenerateNamespaceDeclarationSyntax(e);

			output.WriteLine("");
			output.WriteLine("type");

			Indent++;
			GenerateTypes(e);
			Indent--;

			output.WriteLine();
			output.WriteLine("implementation");
			GenerateImplementations(e);
			GenerateNamespaceEnd(e);
		}

		public void GenerateImplementations(BaseNamespaceDeclarationSyntax e)
		{

			foreach (var type in e.Members)
			{
				if (type is StructDeclarationSyntax)
				{
					GenerateStructType(type as StructDeclarationSyntax, declaration: false);
				}
				else if (type is ClassDeclarationSyntax)
				{
					GenerateClassType(type as ClassDeclarationSyntax, declaration: false);
				}
			}

		}


		void GenerateCodeFromNamespace(BaseNamespaceDeclarationSyntax e, TextWriter w, ObjectPascalCodeGeneratorOptions o)
		{
			bool reset = InitOutput(w, o);
			try
			{
				GenerateNamespace(e, o);
			}
			finally
			{
				ResetOutput(reset);
			}
		}

		private void GenerateNamespaces(CompilationUnitSyntax e, ObjectPascalCodeGeneratorOptions o)
		{
			foreach (var @namespace in e.ChildNodes().OfType<BaseNamespaceDeclarationSyntax>())
			{
				GenerateCommentsTrivia(e);
				GenerateCodeFromNamespace(@namespace, output.InnerWriter, o);
			}
		}

		public virtual void GenerateCompilationUnitEnd(CompilationUnitSyntax e)
		{
		}

		protected virtual void GenerateCodeLetsGo(CompilationUnitSyntax e, ObjectPascalCodeGeneratorOptions o)
		{
			GenerateCompilationUnitStart();
			GenerateNamespaces(e, o);
			GenerateCompilationUnitEnd(e);
		}

		private void GeneratePropertyDeclarationSyntax(PropertyDeclarationSyntax propertyDeclarationSyntax)
		{

			foreach (AccessorDeclarationSyntax accessorDeclarationSyntax in propertyDeclarationSyntax.AccessorList.Accessors)
			{
				if (accessorDeclarationSyntax.IsKind(SyntaxKind.GetAccessorDeclaration))
				{

					if (!(propertyDeclarationSyntax.Parent is InterfaceDeclarationSyntax))
						output.Write("strict private ");

					if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
						output.Write("class ");

					if ((accessorDeclarationSyntax.Body == null) && (accessorDeclarationSyntax.ExpressionBody == null) && !(propertyDeclarationSyntax.Parent is InterfaceDeclarationSyntax)) // auto property
					{
						output.Write("m_" + propertyDeclarationSyntax.Identifier.ValueText + ": " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type));
					}
					else
                    {
                        // Retirado o final do nome PropValue em 10/11/2023 para analise se melhorou
                        // output.Write("function Get" + propertyDeclarationSyntax.Identifier.ValueText + "PropValue(): " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type));
                        output.Write("function Get" + propertyDeclarationSyntax.Identifier.ValueText + "(): " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type));

                        if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("; static");

                        if (ContainsAggressiveInliningMethodImpl(accessorDeclarationSyntax.AttributeLists))
                            output.Write("; inline");
                    }


                    output.WriteLine(";");
				}
				else if (accessorDeclarationSyntax.IsKind(SyntaxKind.SetAccessorDeclaration))
                {
					if ((accessorDeclarationSyntax.Body != null) || (accessorDeclarationSyntax.ExpressionBody != null)  || (propertyDeclarationSyntax.Parent is InterfaceDeclarationSyntax)) // auto property
					{

						if (!(propertyDeclarationSyntax.Parent is InterfaceDeclarationSyntax))
							output.Write("strict private ");

						if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("class ");

                        // Retirado o final do nome PropValue em 10/11/2023 para analise se melhorou
                        // output.Write("procedure Set" + propertyDeclarationSyntax.Identifier.ValueText + "PropValue(const Value: " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type) + ")");
                        output.Write("procedure Set" + propertyDeclarationSyntax.Identifier.ValueText + "(const Value: " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type) + ")");

						if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
							output.Write("; static");

                        if (ContainsAggressiveInliningMethodImpl(accessorDeclarationSyntax.AttributeLists))
                            output.Write("; inline");

                        output.WriteLine(";");
					}
				}
			}

            GenerateCommentsTrivia(propertyDeclarationSyntax);
            GenerateAttributes(propertyDeclarationSyntax.AttributeLists);


            if (!(propertyDeclarationSyntax.Parent is InterfaceDeclarationSyntax))
            {
				if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
					output.Write("public ");
                else if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.InternalKeyword) > -1)
				{
					if (propertyDeclarationSyntax.Parent is StructDeclarationSyntax)
						output.Write("public ");
					else
						output.Write("protected ");
				}
				else if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ProtectedKeyword) > -1)
				{
					if (propertyDeclarationSyntax.Parent is StructDeclarationSyntax)
						output.Write("private ");
					else
						output.Write("strict protected ");
				}
				else if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
					output.Write("strict private ");
				else
					output.Write("public ");
			}

			if (propertyDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write("class ");

			output.Write("property " + CodeGenUtils.CreateEscapedIdentifier(propertyDeclarationSyntax.Identifier.ValueText) + ": " + CSharpToObjectPascalType(propertyDeclarationSyntax.Type));

			foreach (AccessorDeclarationSyntax accessorDeclarationSyntax in propertyDeclarationSyntax.AccessorList.Accessors)
			{
				if (accessorDeclarationSyntax.IsKind(SyntaxKind.GetAccessorDeclaration))
				{
					output.Write(" read ");
					if ((accessorDeclarationSyntax.Body == null) && (accessorDeclarationSyntax.ExpressionBody == null) && !(propertyDeclarationSyntax.Parent is InterfaceDeclarationSyntax)) // auto property
					{
							output.Write("m_" + propertyDeclarationSyntax.Identifier.ValueText);
					}
					else
					{
                        // Retirado o final do nome PropValue em 10/11/2023 para analise se melhorou
                        // output.Write("Get" + propertyDeclarationSyntax.Identifier.ValueText + "PropValue");
                        output.Write("Get" + propertyDeclarationSyntax.Identifier.ValueText);
                    }
				}
				else if (accessorDeclarationSyntax.IsKind(SyntaxKind.SetAccessorDeclaration))
				{
					output.Write(" write ");
					if ((accessorDeclarationSyntax.Body == null) && (accessorDeclarationSyntax.ExpressionBody == null) && !(propertyDeclarationSyntax.Parent is InterfaceDeclarationSyntax)) // auto property
					{
						output.Write("m_" + propertyDeclarationSyntax.Identifier.ValueText);
					}
					else
					{
                        // Retirado o final do nome PropValue em 10/11/2023 para analise se melhorou
                        // output.Write("Set" + propertyDeclarationSyntax.Identifier.ValueText + "PropValue");
                        output.Write("Set" + propertyDeclarationSyntax.Identifier.ValueText);
					}
				}
			}

			output.WriteLine(";");
		}
		
		private void GenerateMethodDeclarationSyntax(MethodDeclarationSyntax methodDeclarationSyntax, bool isOverloaded, bool declaration)
		{

			if (declaration)
			{
				GenerateCommentsTrivia(methodDeclarationSyntax);
                GenerateAttributes(methodDeclarationSyntax.AttributeLists);
            }

            if ((declaration) && !(methodDeclarationSyntax.Parent is InterfaceDeclarationSyntax))
			{
				if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
					output.Write("public ");
                else if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.InternalKeyword) > -1)
				{
					if (methodDeclarationSyntax.Parent is StructDeclarationSyntax)
						output.Write("public ");
					else
						output.Write("protected ");
				}
				else if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ProtectedKeyword) > -1)
				{
					if (methodDeclarationSyntax.Parent is StructDeclarationSyntax)
						output.Write("private ");
					else
						output.Write("strict protected ");
				}
				else if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
					output.Write("strict private ");
				else
					output.Write("public ");
			}

			if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write("class ");


			if (!methodDeclarationSyntax.ReturnType.ToString().Equals("void"))
				output.Write("function ");
			else
				output.Write("procedure ");


			if (!declaration) 
			{

				var qualifiedNames = new List<string>();
				if (methodDeclarationSyntax.Parent is TypeDeclarationSyntax)
				{
					TypeDeclarationSyntax typeDeclarationSyntax = methodDeclarationSyntax.Parent as TypeDeclarationSyntax;

					qualifiedNames.Add(CSharpToObjectPascalType(typeDeclarationSyntax.Identifier.ValueText));
					if (typeDeclarationSyntax.TypeParameterList != null)
						qualifiedNames[0] += typeDeclarationSyntax.TypeParameterList.ToString();

					var parentType = typeDeclarationSyntax.Parent as TypeDeclarationSyntax;

					while (parentType != null)
					{
						qualifiedNames.Insert(0, CSharpToObjectPascalType(parentType.Identifier.ValueText));
						parentType = parentType.Parent as TypeDeclarationSyntax;
					}
				}

				foreach (var item in qualifiedNames)
                {
					output.Write(item);

					if (!item.Equals(qualifiedNames.Last()))
                    {
						output.Write(".");
					}
				}


				output.Write(".");
			}

			output.Write(CodeGenUtils.CreateEscapedIdentifier(methodDeclarationSyntax.Identifier.ValueText));
			if (methodDeclarationSyntax.TypeParameterList != null)
				output.Write(methodDeclarationSyntax.TypeParameterList.ToString());

			output.Write("(");

			if (methodDeclarationSyntax.ParameterList != null)
			{
				SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = methodDeclarationSyntax.ParameterList.Parameters;
				foreach (ParameterSyntax param in parameterSyntaxCollection)
				{

					if (methodDeclarationSyntax.Identifier.ValueText.Equals("IterateCommentRanges") && param.Identifier.ValueText.Equals("cb"))
					{
						//Console.WriteLine();
					}


					if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
						output.Write("const ");
					else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
						output.Write("var ");
					else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
						output.Write("out ");
					else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
						output.Write("const ");
					else if (param.Modifiers.IndexOf(SyntaxKind.ThisKeyword) > -1)
						output.Write("(*Self*) const [ref] ");
					else
						output.Write("const ");

					output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.ValueText));
					output.Write(": " + CSharpToObjectPascalType(param.Type));

					if (param.Default != null)
                    {
						output.Write(" = ");
						GenerateExpressionSyntax(param.Default.Value);
                    }


					if (!param.Equals(parameterSyntaxCollection.Last()))
						output.Write("; ");
				}

			}


			output.Write(")");

			if (!methodDeclarationSyntax.ReturnType.ToString().Equals("void"))
				output.Write(": " + CSharpToObjectPascalType(methodDeclarationSyntax.ReturnType));

			if (declaration)
			{
				if (isOverloaded)
					output.Write("; overload");

				if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.OverrideKeyword) > -1 && methodDeclarationSyntax.Parent is ClassDeclarationSyntax)
					output.Write("; override");


				if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.VirtualKeyword) > -1)
					output.Write("; virtual");

				if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.AbstractKeyword) > -1)
                {
					if (!(methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.VirtualKeyword) > -1))
						output.Write("; virtual");

					output.Write("; abstract");
				}

				if (methodDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
					output.Write("; static");

				if (ContainsAggressiveInliningMethodImpl(methodDeclarationSyntax.AttributeLists))
				{
                    output.Write("; inline");
                }



            }

            if (methodDeclarationSyntax.Identifier.ToString() == "SetNativeBrush")
            {

            }

            output.Write(";");       
            GenerateTriviaListSyntax(methodDeclarationSyntax.ParameterList.CloseParenToken.TrailingTrivia, true);
            GenerateTriviaListSyntax(methodDeclarationSyntax.SemicolonToken.TrailingTrivia, true);
        }

        private bool ContainsAggressiveInliningMethodImpl(SyntaxList<AttributeListSyntax> attributeLists)
        {
            foreach(AttributeListSyntax attribute in attributeLists)
			{
				if (attribute.ToString() == "[MethodImpl(MethodImplOptions.AggressiveInlining)]")
				{
					return true;
				}
			}

			return false;
        }

		private void GenerateTriviaListSyntax(SyntaxTriviaList syntaxTriviaList, bool outputWhitespaces = false)
		{

          //  bool outputEndOfLineTrivia = true;
            int currentIndent = output.Indent;

            foreach (SyntaxTrivia syntaxTrivia in syntaxTriviaList)
            {
                switch (syntaxTrivia.Kind())
                {
                    case SyntaxKind.SingleLineDocumentationCommentTrivia:
                        {
                            string originalText = syntaxTrivia.ToFullString();
							string translatedText = TranslatorService.TranslateText(originalText);
                            string[] items = translatedText.Split('\n');

                            if (items.Length > 0)
                            {
                               output.WriteLine();

                                foreach (var item in items)
                                {
                                    if (!string.IsNullOrEmpty(item))
                                        output.WriteLine(item.Trim());
                                }
                            }
                            else
                            {
                                throw new NotImplementedException("verificar por que isso acontece! 25/03/2024-2:");
                            }

                            //outputEndOfLineTrivia = false;
                            //output.WriteLine();
                            break;
                        }

                    case SyntaxKind.SingleLineCommentTrivia:
                        {
                            string originalText = syntaxTrivia.ToString().Trim();
                            string translatedText = TranslatorService.TranslateText(originalText);

                            output.Write(translatedText);
                            //outputEndOfLineTrivia = !outputWhitespaces;
                            break;
                        }

                    case SyntaxKind.WhitespaceTrivia:
                        {
                            if (outputWhitespaces)
                                output.Write(syntaxTrivia.ToFullString());

                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.EndOfLineTrivia:
                        {
                            //if (outputEndOfLineTrivia)
                            {
                                output.WriteLine();
                              //  outputEndOfLineTrivia = false;
                            }
                            break;
                        }

                    case SyntaxKind.IfDirectiveTrivia:
                        {
                            string item = syntaxTrivia.ToString().Trim();

                            item = item.Replace("#if", "{$IFDEF", StringComparison.OrdinalIgnoreCase) + "}";

                            output.Indent = 0;
                            output.WriteLine(item);
                            output.Indent = currentIndent;

                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.ElseDirectiveTrivia:
                        {
                            string item = syntaxTrivia.ToString().Trim();

                            item = item.Replace("#else", "{$ELSE", StringComparison.OrdinalIgnoreCase) + "}";

                            output.Indent = 0;
                            output.WriteLine(item);
                            output.Indent = currentIndent;

                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.EndIfDirectiveTrivia:
                        {
                            string item = syntaxTrivia.ToString().Trim();

                            item = item.Replace("#endif", "{$ENDIF", StringComparison.OrdinalIgnoreCase) + "}";

                            output.Indent = 0;
                            output.WriteLine(item);
                            output.Indent = currentIndent;

                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.BadDirectiveTrivia:
                        {
                            output.Indent = 0;
                            output.WriteLine(SyntaxKind.BadDirectiveTrivia);
                            output.WriteLine(syntaxTrivia.ToFullString().Trim());
                            output.Indent = currentIndent;

                            //outputEndOfLineTrivia = false;
                            break;
                        }
                    case SyntaxKind.ElifDirectiveTrivia:
                        {
                            string item = syntaxTrivia.ToString().Trim();

                            item = item.Replace("#elif", "{$ELSEIF", StringComparison.OrdinalIgnoreCase) + "}";

                            output.Indent = 0;
                            output.WriteLine(item);
                            output.Indent = currentIndent;

                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.DefineDirectiveTrivia:
                        {
                            string item = syntaxTrivia.ToString().Trim();

                            item = item.Replace("#define", "{$DEFINE", StringComparison.OrdinalIgnoreCase) + "}";

                            output.Indent = 0;
                            output.WriteLine(item);
                            output.Indent = currentIndent;

                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.UndefDirectiveTrivia:
                        {
                            string item = syntaxTrivia.ToString().Trim();

                            item = item.Replace("#undef", "{$UNDEF", StringComparison.OrdinalIgnoreCase) + "}";

                            output.Indent = 0;
                            output.WriteLine(item);
                            output.Indent = currentIndent;

                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.RegionDirectiveTrivia:
                        {
                            string strInput = syntaxTrivia.ToString().Trim();
                            string directive = "#region";

                            string strOutput = "{$REGION";

                            if (strInput.Length > directive.Length)
                                strOutput = strOutput + " '" + strInput.Substring(directive.Length).Trim() + "'}";

                            strOutput = strOutput + "}";

                            output.Indent = 0;
                            output.WriteLine(strOutput);
                            output.Indent = currentIndent;

                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.EndRegionDirectiveTrivia:
                        {
                            string strInput = syntaxTrivia.ToString().Trim();
                            string directive = "#endregion";

                            string strOutput = "{$ENDREGION";

                            if (strInput.Length > directive.Length)
                                strOutput = strOutput + " '" + strInput.Substring(directive.Length).Trim() + "'}";

                            strOutput = strOutput + "}";

                            output.Indent = 0;
                            output.WriteLine(strOutput);
                            output.Indent = currentIndent;

                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.DisabledTextTrivia:
                        {
                            output.WriteLine(syntaxTrivia.ToFullString().Trim());
                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.PragmaWarningDirectiveTrivia:
                        {
                            output.WriteLine("// " + syntaxTrivia.ToFullString().Trim());
                            //outputEndOfLineTrivia = false;
                            break;
                        }

                    default:
                        {

                            var node = syntaxTrivia;
                            var kind = node.Kind();
                            FileLinePositionSpan span = node.SyntaxTree.GetLineSpan(node.Span);
                            int lineNumber = span.StartLinePosition.Line + 1;

                            output.WriteLine();
                            output.WriteLine("  //");
                            output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                            output.WriteLine("  // Kind: " + node.Kind().ToString());
                            output.WriteLine("  // Type: " + node.GetType().Name);
                            output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                            output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                            output.WriteLine("  // Linha: " + lineNumber.ToString());
                            output.WriteLine("  // Metodo: GenerateLeadingTrivia()");
                            output.WriteLine("  //");
                            output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                            output.WriteLine(node.ToFullString());
                            output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 25/03/2024-1 ------------");
                            output.WriteLine("  //");

                            break;
                        }
                }
            }

            output.Indent = currentIndent;

        }

        private void GenerateLeadingTriviaSyntax(SyntaxNode e)
		{
			GenerateTriviaListSyntax(e.GetLeadingTrivia(), false);
        }

        private void GenerateTrailingTriviaSyntax(SyntaxNode e)
		{
            int currentIndent = output.Indent;
            bool outputEndOfLineTrivia = false;

            SyntaxTriviaList syntaxTriviaList = e.GetTrailingTrivia();
			foreach (SyntaxTrivia syntaxTrivia in syntaxTriviaList)
			{
                switch (syntaxTrivia.Kind())
                {
                    case SyntaxKind.WhitespaceTrivia:
                        {
                                output.Write(syntaxTrivia.ToString());
                                outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.SingleLineCommentTrivia:
                        {
                            string originalText = syntaxTrivia.ToString();
                            string translatedText = TranslatorService.TranslateText(originalText);
                            output.Write(translatedText);
                            outputEndOfLineTrivia = false;
                            break;
                        }

                    case SyntaxKind.EndOfLineTrivia:
                        {
                            if (outputEndOfLineTrivia)
                            {
                                output.WriteLine();
                                outputEndOfLineTrivia = false;
                            }
                            break;
                        }
                    default:
                        {

                            var node = syntaxTrivia;
                            var kind = node.Kind();
                            FileLinePositionSpan span = node.SyntaxTree.GetLineSpan(node.Span);
                            int lineNumber = span.StartLinePosition.Line + 1;

                            output.WriteLine();
                            output.WriteLine("  //");
                            output.WriteLine("  // não implementado pelo ObjectPascalCodeGenerator: " + kind.ToString());
                            output.WriteLine("  // Kind: " + node.Kind().ToString());
                            output.WriteLine("  // Type: " + node.GetType().Name);
                            output.WriteLine("  // Arquivo: " + node.SyntaxTree.FilePath);
                            output.WriteLine("  // Posição: " + node.FullSpan.ToString());
                            output.WriteLine("  // Linha: " + lineNumber.ToString());
                            output.WriteLine("  // Metodo: GenerateTrailingSyntax()");
                            output.WriteLine("  //");
                            output.WriteLine("  // ----------- começa aqui o que não é suportado ------------");
                            output.WriteLine(node.ToFullString());
                            output.WriteLine("  // ----------- TERMINA AQUI O QUE É SEM SUPORTE - 25/03/2024-2 ------------");
                            output.WriteLine("  //");

                            break;
                        }
                }

            }

            output.Indent = currentIndent;
        }

        private void GenerateCommentsTrivia(SyntaxNode e)
        {
            GenerateLeadingTriviaSyntax(e);
        }

        private void GenerateConstructorDeclarationSyntax(ConstructorDeclarationSyntax constructorDeclarationSyntax, bool isOverloaded, bool declaration)
		{

			if (declaration)
			{
				GenerateCommentsTrivia(constructorDeclarationSyntax);
				GenerateAttributes(constructorDeclarationSyntax.AttributeLists);

				if (constructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
					output.Write("public ");
                else if (constructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.InternalKeyword) > -1)
				{
					if (constructorDeclarationSyntax.Parent is StructDeclarationSyntax)
						output.Write("public ");
					else
						output.Write("protected ");
				}
				else if (constructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ProtectedKeyword) > -1)
				{
					if (constructorDeclarationSyntax.Parent is StructDeclarationSyntax)
						output.Write("private ");
					else
						output.Write("strict protected ");
				}
				else if (constructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
					output.Write("strict private ");
				else
					output.Write("public ");
			}

			if (constructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
				output.Write("class ");

			output.Write("constructor ");

			if (!declaration)
			{

				var qualifiedNames = new List<string>();
				if (constructorDeclarationSyntax.Parent is ClassDeclarationSyntax)
				{
					ClassDeclarationSyntax classDeclarationSyntax = constructorDeclarationSyntax.Parent as ClassDeclarationSyntax;

					qualifiedNames.Add(CSharpToObjectPascalType(classDeclarationSyntax.Identifier.ValueText));
                    if (classDeclarationSyntax.TypeParameterList != null)
                        qualifiedNames[0] += classDeclarationSyntax.TypeParameterList.ToString();
                    var parentClass = classDeclarationSyntax.Parent as ClassDeclarationSyntax;

					while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
					{
						qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
						parentClass = parentClass.Parent as ClassDeclarationSyntax;
					}
				}
				else if (constructorDeclarationSyntax.Parent is StructDeclarationSyntax)
                {
					StructDeclarationSyntax structDeclarationSyntax = constructorDeclarationSyntax.Parent as StructDeclarationSyntax;
					qualifiedNames.Add(CSharpToObjectPascalType(structDeclarationSyntax.Identifier.ValueText));
                    if (structDeclarationSyntax.TypeParameterList != null)
                        qualifiedNames[0] += structDeclarationSyntax.TypeParameterList.ToString();

                    if (structDeclarationSyntax.Parent is ClassDeclarationSyntax)
					{
						ClassDeclarationSyntax classDeclarationSyntax = structDeclarationSyntax.Parent as ClassDeclarationSyntax;
						var parentClass = classDeclarationSyntax;

						while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
						{
							qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
							parentClass = parentClass.Parent as ClassDeclarationSyntax;
						}
					}
				}

				foreach (var item in qualifiedNames)
				{
					output.Write(item);

					if (!item.Equals(qualifiedNames.Last()))
					{
						output.Write(".");
					}
				}


				output.Write(".");
			}

			output.Write("Create(");

			if (constructorDeclarationSyntax.ParameterList != null)
			{
				SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = constructorDeclarationSyntax.ParameterList.Parameters;
				foreach (ParameterSyntax param in parameterSyntaxCollection)
				{
					if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
						output.Write("const ");
					else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
						output.Write("var ");
					else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
						output.Write("out ");
					else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
						output.Write("const ");
					else
						output.Write("const ");

					output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.Text));
					output.Write(": " + CSharpToObjectPascalType(param.Type));

					if (param.Default != null)
					{
						output.Write(" = ");
						GenerateExpressionSyntax(param.Default.Value);
					}

					if (!param.Equals(parameterSyntaxCollection.Last()))
						output.Write("; ");
				}

			}


			output.Write(")");

			if (declaration)
			{
				if (isOverloaded)
					output.Write("; overload");

				if (constructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.OverrideKeyword) > -1 && constructorDeclarationSyntax.Parent is ClassDeclarationSyntax)
					output.Write("; override");


				if (constructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.VirtualKeyword) > -1)
					output.Write("; virtual");

				if (constructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.AbstractKeyword) > -1)
					output.Write("; abstract");

				if (constructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
					output.Write("; static");
			}

			output.WriteLine(";");
		}

        private void GenerateDestructorDeclarationSyntax(DestructorDeclarationSyntax destructorDeclarationSyntax, bool isOverloaded, bool declaration)
        {

            if (declaration)
            {
                GenerateCommentsTrivia(destructorDeclarationSyntax);
                GenerateAttributes(destructorDeclarationSyntax.AttributeLists);

                if (destructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PublicKeyword) > -1)
                    output.Write("public ");
                else if (destructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.InternalKeyword) > -1)
                {
                    if (destructorDeclarationSyntax.Parent is StructDeclarationSyntax)
                        output.Write("public ");
                    else
                        output.Write("protected ");
                }
                else if (destructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.ProtectedKeyword) > -1)
                {
                    if (destructorDeclarationSyntax.Parent is StructDeclarationSyntax)
                        output.Write("private ");
                    else
                        output.Write("strict protected ");
                }
                else if (destructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.PrivateKeyword) > -1)
                    output.Write("strict private ");
                else
                    output.Write("public ");
            }

            if (destructorDeclarationSyntax.Modifiers.IndexOf(SyntaxKind.StaticKeyword) > -1)
                output.Write("class ");

            output.Write("destructor ");

            if (!declaration)
            {

                var qualifiedNames = new List<string>();
                if (destructorDeclarationSyntax.Parent is ClassDeclarationSyntax)
                {
                    ClassDeclarationSyntax classDeclarationSyntax = destructorDeclarationSyntax.Parent as ClassDeclarationSyntax;

                    qualifiedNames.Add(CSharpToObjectPascalType(classDeclarationSyntax.Identifier.ValueText));
                    if (classDeclarationSyntax.TypeParameterList != null)
                        qualifiedNames[0] += classDeclarationSyntax.TypeParameterList.ToString();
                    var parentClass = classDeclarationSyntax.Parent as ClassDeclarationSyntax;

                    while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
                    {
                        qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
                        parentClass = parentClass.Parent as ClassDeclarationSyntax;
                    }
                }
                else if (destructorDeclarationSyntax.Parent is StructDeclarationSyntax)
                {
                    StructDeclarationSyntax structDeclarationSyntax = destructorDeclarationSyntax.Parent as StructDeclarationSyntax;
                    qualifiedNames.Add(CSharpToObjectPascalType(structDeclarationSyntax.Identifier.ValueText));
                    if (structDeclarationSyntax.TypeParameterList != null)
                        qualifiedNames[0] += structDeclarationSyntax.TypeParameterList.ToString();

                    if (structDeclarationSyntax.Parent is ClassDeclarationSyntax)
                    {
                        ClassDeclarationSyntax classDeclarationSyntax = structDeclarationSyntax.Parent as ClassDeclarationSyntax;
                        var parentClass = classDeclarationSyntax;

                        while (parentClass != null && parentClass.Kind() == SyntaxKind.ClassDeclaration)
                        {
                            qualifiedNames.Insert(0, CSharpToObjectPascalType(parentClass.Identifier.ValueText));
                            parentClass = parentClass.Parent as ClassDeclarationSyntax;
                        }
                    }
                }

                foreach (var item in qualifiedNames)
                {
                    output.Write(item);

                    if (!item.Equals(qualifiedNames.Last()))
                    {
                        output.Write(".");
                    }
                }


                output.Write(".");
            }

            output.Write("Destroy(");

            if (destructorDeclarationSyntax.ParameterList != null)
            {
                SeparatedSyntaxList<ParameterSyntax> parameterSyntaxCollection = destructorDeclarationSyntax.ParameterList.Parameters;
                foreach (ParameterSyntax param in parameterSyntaxCollection)
                {
                    if (param.Modifiers.IndexOf(SyntaxKind.ConstKeyword) > -1)
                        output.Write("const ");
                    else if (param.Modifiers.IndexOf(SyntaxKind.RefKeyword) > -1)
                        output.Write("var ");
                    else if (param.Modifiers.IndexOf(SyntaxKind.OutKeyword) > -1)
                        output.Write("out ");
                    else if (param.Modifiers.IndexOf(SyntaxKind.InKeyword) > -1)
                        output.Write("const ");
                    else
                        output.Write("const ");

                    output.Write(CodeGenUtils.CreateEscapedIdentifier(param.Identifier.Text));
                    output.Write(": " + CSharpToObjectPascalType(param.Type));

                    if (param.Default != null)
                    {
                        output.Write(" = ");
                        GenerateExpressionSyntax(param.Default.Value);
                    }

                    if (!param.Equals(parameterSyntaxCollection.Last()))
                        output.Write("; ");
                }

            }


            output.Write(")");

            if (declaration)
            {
                    output.Write("; override");
            }

            output.WriteLine(";");
        }


        public static String CSharpToObjectPascalType(RefTypeSyntax refType)
		{
			var result = InternalCSharpToObjectPascalTypeSyntax(refType.Type);

			if (result.StartsWith("T"))
				result = result.Substring(1);

			result = 'P' + result;

			return result;
		}

		public static String CSharpToObjectPascalType(TypeSyntax type)
        {
			if (type is RefTypeSyntax refType)
				return CSharpToObjectPascalType(refType);
			else
				return InternalCSharpToObjectPascalTypeSyntax(type);
		}

		private static String InternalCSharpToObjectPascalTypeSyntax(TypeSyntax pType)
		{

			if (pType is null)
			{
				return "TRttiValue";
			}
			else if (pType is NullableTypeSyntax)
            {
				var nullableTypeSyntax = pType as NullableTypeSyntax;
                // return "Nullable<" + CSharpToObjectPascalType(nullableTypeSyntax.ElementType.ToString()) + ">";
                return CSharpToObjectPascalType(nullableTypeSyntax.ElementType.ToString());

            }
            else if (pType is PointerTypeSyntax)
			{
				var pointerTypeSyntax = pType as PointerTypeSyntax;
				if (pointerTypeSyntax.ElementType.ToString() == "void")
					return "Pointer";
				else
					return "P" + CSharpToObjectPascalType(pointerTypeSyntax.ElementType.ToString());

			}
			else if (pType is GenericNameSyntax)
			{
				var genericName = pType as GenericNameSyntax;
				var nameParts = new StringBuilder();

				nameParts.Append(CSharpToObjectPascalType(genericName.Identifier.ValueText));

				nameParts.Append("<");
				foreach (var argumentType in genericName.TypeArgumentList.Arguments)
                {
					nameParts.Append(CSharpToObjectPascalType(argumentType));
					
					if (!argumentType.Equals(genericName.TypeArgumentList.Arguments.Last()))
						nameParts.Append(", ");
				}
				nameParts.Append(">");


				return CSharpToObjectPascalType(nameParts.ToString());

			}
			else
            {
				return CSharpToObjectPascalType(pType.ToString());
			}

		}

		public static String CSharpToObjectPascalType(String pTypeName)
		{
			if (pTypeName.Contains("["))
			{
				String[] p1 = pTypeName.Split('[');
				return $"TArray<{CSharpToObjectPascalType(p1[0])}>";
			}
			//if (pTypeName.Contains("<"))
			//{
			//	String[] p1 = pTypeName.Split('<');
			//	String[] p2 = p1[1].Split(new[] { ">" }, StringSplitOptions.RemoveEmptyEntries);
			//	p2 = p2[0].Split(new[] { "," }, StringSplitOptions.RemoveEmptyEntries);

			//	return $"{CSharpToObjectPascalType(p1[0])}<{String.Join(", ", p2.Select(v => CSharpToObjectPascalType(v)).ToArray())}>";
			//}
			switch (pTypeName)
			{
				case "int":
				case "Int":
					return "Integer";

				case "uint":
				case "UInt":
					return "UInt32";

				case "nint":
				case "NInt":
					return "NativeInt";

				case "nuint":
				case "NUInt":
					return "NativeUInt";

				case "Boolean":
				case "bool":
					return "Boolean";

				case "Array":
					return "TArray";

				case "StringBuilder":
					return "TStringBuilder";

				case "DateTime":
					return "TDatetime";

				case "long":
				case "Long":
					return "Int64";

				case "ulong":
				case "ULong":
					return "UInt64";

				case "Guid":
					return "TGuid";

				case "object":
					return "TObject";

				case "decimal":
				case "Decimal":
					return "Decimal";

				case "Double":
				case "double":
					return "Double";

				case "float":
				case "Float":
					return "Single";

				case "byte":
				case "Byte":
					return "Byte";

				case "byte*":
					return "PByte";

				case "sbyte":
				case "SByte":
					return "Int8";

				case "string":
				case "String":
					return "string";

				case "short":
				case "Short":
					return "Int16";

				case "Type":
				case "TType":
					return "TRttiType";

					
				case "TIntPtr":
				case "IntPtr":
					return "Pointer";

				//case "Rectangle":
				//case "TRectangle":
				//	return "TRect";

				case "ushort":
					return "UInt16";

				case "char":
					return "Char";

				case "List":
					return "TList";

				case "ReadOnlyCollection":
					return "TReadOnlyCollection";
                case "Pointer":
                    return "Pointer";


                default:
					if (pTypeName.Length < 2)
						return pTypeName;
					else if (pTypeName.StartsWith("I") && Char.IsUpper(pTypeName[1]))
						return pTypeName;
					else if (pTypeName.StartsWith("T") && Char.IsUpper(pTypeName[1]))
						return pTypeName;
					else if (pTypeName.EndsWith("Exception"))
						return "E" + pTypeName;
					else
					{
                        return "T" + pTypeName.Replace(".", ".T");
                    }
						
			}
		}

	}

    public static partial class Extensions
    {
        /// <summary>
        ///     A char extension method that repeats a character the specified number of times.
        /// </summary>
        /// <param name="this">The @this to act on.</param>
        /// <param name="repeatCount">Number of repeats.</param>
        /// <returns>The repeated char.</returns>
        public static string Repeat(this char @this, int repeatCount)
        {
            return new string(@this, repeatCount);
        }
    }

}
